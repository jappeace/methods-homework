include: person.2apl;

beliefs:
  clean( blockWorld ) :- not bomb(X,Y) , not carry(bomb).
  score(0).
  knowtrap( blockWorld ) :- trap(X, Y).
  shouldFollowSally( blockWorld ) :- knowtrap( blockWorld ), not bomb( X, Y).

beliefupdates:
  { carry(bomb) }     Drop()   { not carry(bomb)}
  { not carry(bomb) and score(N) } PickUp() { carry(bomb), score(N + 1), not score(N)}
  { sally(Q, Z)} LocateSally(X1, Y1) { sally(X1, Y1), not sally(Q,Z)}

plans:
  startup(0, 1, blue);

goals:
  clean( blockWorld ).
  findtrap ( blockWorld ).
  followSally( blockWorld ).
  findSally ( blockWorld ).

pgrules:
  clean( blockWorld ) <- knowtrap(blockWorld) and bomb( X, Y ) and trap (Q, Z)|
  {
    goto( X, Y );
    @blockworld( pickup( ), _ );
		PickUp();
		-bomb( X, Y );
    goto(Q, Z);
		@blockworld( drop( ), _ );
		Drop();
  }
  findSally( blockWorld ) <- shouldFollowSally( blockWorld )|
  {
    @blockworld( senseAllAgent(), AGENTS);
	if B( AGENTS = [[sally, X, Y]]){
		if B(not sally(A, B)){
			+sally(0,0);
		}
		LocateSally(X, Y);
	}
  }
  followSally( blockWorld ) <-shouldFollowSally( blockWorld ) and sally(Q,Z)|
  {
    goto( Q, Z );

  }
  findtrap( blockWorld ) <- not knowtrap(blockWorld) and worldSize(W, H) |
  {
    B(is( X, int( random( W - 1 ) ) ));
    B(is( Y, int( random( H - 1 ) ) ));
    goto( X, Y );
    @blockworld( senseTraps(), TRAPS);
    if B( TRAPS = [[default,X1,Y1]|REST] )
    {
		+trap(X1, Y1);
    }
  }

pcrules:
  message( sally, inform, La, On, bombAt( X, Y ) ) <- true |
  {
    if B( not bomb( A, B ) ) {
      +bomb(X, Y);
      adoptz( clean( blockWorld ) );
    }
    else {
			+bomb( X, Y );
		}
  }
prrules:
  @blockworld( pickup(), _ ); REST; <- true |
  {
    @blockworld( sensePosition(), POS );
    B(POS = [X,Y]);
    -bomb(X, Y );
  }
