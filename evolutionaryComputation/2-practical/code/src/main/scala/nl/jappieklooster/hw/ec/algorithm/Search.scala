package nl.jappieklooster.hw.ec.algorithm

import nl.jappieklooster.hw.ec.model.{Population, IMember, Graph}

import scala.annotation.tailrec
import scala.util.Random

import Search._

/**
 * Search, it depends on how you configure it if its global or local.
 * it executes the search method, then checks if its happy, if not it'll
 * try again, if so the decideResult is called
 * @param method
 * @param stopCondition
 * @param decideResult
 */
class Search(
		method:SearchMethod,
		stopCondition:StopCondition = StopCondition.onEqual,
		decideResult:ResultDecision = ResultDecision.current
	){
	@tailrec
	final def search(previous: IMember):IMember = {
		val result = method(previous)
		if(stopCondition(result,previous)){
			return decideResult(result, previous)
		}else{
			return search(result)
		}
	}
}
object Search {
	type SearchMethod = IMember => IMember
	type StopCondition = (IMember, IMember)=>Boolean
	object StopCondition{
		def onEqual(a:IMember, b:IMember):Boolean = a==b
		def isWorse(a:IMember, b:IMember):Boolean = a.fitness < b.fitness
		def resetRetryOnBetter(which:RetryOnResult, stopCondition: StopCondition)(current: IMember, previous: IMember): Boolean = {
			val result = stopCondition(current,previous)
			if(!result){
				which.reset
			}
			result
		}
	}
	type ResultDecision = (IMember, IMember) => IMember
	object ResultDecision{
		def current(cur:IMember, prev:IMember) = cur
		def previous(cur:IMember, prev:IMember) = prev
	}

	object Iterative{
		def swapMutation(times:Int, random:Random, memberFactory:String => IMember)(member:IMember):IMember ={
			val gen = member.genes
			def randomGenePoint = random.nextInt(gen.length)
			def create(prev:String, x:Int):String = {
				val one = randomGenePoint
				val two = randomGenePoint
				val acmp = prev(one)
				val bcmp = prev(two)
				if(acmp == bcmp){
					create(prev,x)
				}else{
					val result = swapChar(prev)(one, two)
					result
				}
			}

			return memberFactory(1.to(times).foldLeft(gen)(create))
		}
	}
	/**
	* Swap characters at specified positions.
	*/
	def swapChar(partitioning:String)(one:Int, two:Int):String = { // how is this not a standard function?!
		val builder = new StringBuilder(partitioning)
		builder.setCharAt(one, partitioning(two))
		builder.setCharAt(two, partitioning(one))
		builder.mkString
	}
	/**
	* The local search algorithm we use is the vertex
	* swap neighborhood search (VSN). In VSN a neighboring solution is generated by swapping
	* two vertices, one from each partitioning.
	*/
	def vertexSwapFirstImprovement(graph:Graph, memberFactory:String => IMember)(member:IMember):IMember = {
		val partitioning = member.genes

		// swapping of vertex in partitions
		val swapVertex = swapChar(member.genes) _

		// I just don't know a good way to do this with recursion or combbinators
		for(index <- 0.to(graph.verteci.length-1)){
			val vert = graph.verteci(index)
			val options = vert.connections.filter(conindx => partitioning(index) != partitioning(conindx))

			var lastMember:IMember = null // optimization, prevents member creation and valuation twice

			// first improvement variant
			val result = options.find(conindx => {
				lastMember = memberFactory(swapVertex(conindx, index))
				lastMember.fitness > member.fitness
			})
			if(!result.isEmpty){
				return lastMember
			}

		}
		member
	}

	class Probe extends SearchMethod{
		var tracked = List[IMember]()
		override def apply(member: IMember): IMember = {
			tracked = tracked :+ member
			member
		}
	}
	class RetryOnResult(repitions:Int, var method: SearchMethod) extends ResultDecision{
		val resetvalue = 0
		private var current = resetvalue
		override def apply(result: IMember, previous: IMember): IMember = {
			current += 1
			if(current < repitions){
				method(previous)
			}
			result
		}
		def reset = current = resetvalue
	}
}
