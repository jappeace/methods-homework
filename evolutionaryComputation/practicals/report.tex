\documentclass{article}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{booktabs}
\usepackage{color}
\usepackage{bussproofs}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{qtree}
\usepackage{tikz}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{svg}
\newenvironment{scprooftree}[1]%
{\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
{\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }


\newcommand{\brcell}[2][l]{%
	\begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}
\begin{document}
\author{Jappie Klooster}
\title{A practical look at genetic algorithms}
\maketitle

\section{Introduction}
This is a report of the evolutionary practical assigment 1.
In here I will discuss what this assignment contained, which
methodology I used to execute the assignemnt and how the execution
went.

The intended audiance is people familiar with programming.

\section{Assignment}
The assignment was to implement the following functions and algorithms and
then do experimentation with help of these.

\subsection{Functions}
\subsubsection{Counting functions}
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}x_i\]
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}i x_i\]
\subsubsection{Trap function}
\[TF(x_1\dots x_l) = \sum^{\frac{l}{k}-1}_{j=0}B(x_{jk_1}\dots x_{jk+k})\]

with:

\[B(x_1\dots x_k)=\left\{
	\begin{matrix}
		k & \mbox{ if } &   CO(x_1\dots x_k) = k \\
		k - d - \frac{k-d}{k-1} CO(x) & \mbox{ if } & CO(x_1\dots x_k) < k \\
	\end{matrix}
\right. \]
\section{Methodology}
\subsection{Build tool}
I use Gradle for building the project. Its the most advanced build platform
available and makes it easy to add dependencies to the project.
For example I use slf4j for logging.

Its also handy in that it comes with a self installing script that can be run
from any platform, Gradlew. So running the code I wrote on a different machine
becomes easy, Gradle makes sure the right dependencies are fetched.

\subsubsection{Run guide}
As said before its a trivial task to run the code. Downloading and installing
of dependencies and even gradle happens automatically with help of gradlew.
So the first run is slower, depending on your internet speed.

\subsubsection{Libraries used}

\subsection{Language choice}
I chose to use Scala to implement this project. The main reason being that I've
played with Scala before but never have done anything constructive with it.

Scala is both a functional and an object orientated program that runs on the JVM
It compiles to byte-code and is statically typed.

It also can use any Java library and integrates seamlessly with Java, (although
calling methods the methods of a Scala project from a Java project can be
a little clumsy sometimes, because Scala supports operator overloading in
a strange way).

Other options I considered were:
\begin{itemize}
	\item Java, which I'm very familiar with but I find quite boring to use.
		Its very verbose.
	\item C\#, the language is good but setting it up is difficult since I
		use Linux, it also has no Gradle support which makes it clunky,
		you'd have to rely on .net libraries only which is limited. It
		also prefers object orientated  rather than functional programming,
		Scala prefers functional over object orientated.
		Scala's syntax is also more concise.
	\item Rust/Go, I'm curious about both these languages, but I'm not at
		all familiar with them, so I probably should do first a little
		hobby project with them before starting doing something serious like
		this, I've already done this with Scala before.
\end{itemize}
\subsection{Architecture}
The architecture was created incrementally, I just implemented the functions
without thinking much about how to combine them.  I first started with the
fittest functions. Then I went on with selection, and finally I did the
crossover.
I just implemented one or 2 options of these and then created an evolution
class that accepted functions with the right prototype. So now you can
create an evolution by giving it functions.

\subsubsection{Unit tests}
Because the assignment has very well defined behavior. I thought it was
a very wise Idea to use unit tests. To do this I use a library called
Scala test.

\paragraph{Bugs found}
Linearly scaled reported the wrong value because it used indeci, so it
gave the first 1 a value of 0, and the second a value of 1 etc.

Trap functions were simply wrongly implemented, instead of counting the
ones they gave positional values of the ones in the block and used the
block as a lookup value for that.

Trap function actually reversed the output. I suspected the trap function
was doing it wrong because all the GA's kept failing, so I added a bunch
of very specific test for each block result which confirmend my suspicion.
The actuall bug was a simple reverse, which meant  the population, slowly
leaned towards 0's instead of 1's. and since my 'solution' is a string
of only ones, the end result is that the bisectional search kept increasing
the population size since now anwser was found and the algoritm wasn't happy.

All valuation functions should return a float instead of an Int.
I don't even understan how I could make such a stupid mistake until the
unit test pointed it out to me. (programming for 6+ years..)

\subsection{Uncertainties}
Should the elitism selection use tournement selection?
When precisly do we find the optimal solution?
	Should I wait for convergence or just say a string
	of all ones is good enough?
	Is 1 solution good enough or should all members have
	that solution
	I'm assuming 1 solution and that I can give a string
	of just ones.
How many generations to consider. I chose arbitrarly 10.

About randomly linked:
	There is another way to do it: for every member randomly link
	differently, and randomly pick 1 randomly linked instructionset
	for offspring generation (or do the strongest).
	Currently I do the global randomly linked, every run will however
	have the same randomly linked value, I'm aware of this.

I'm not quite sure about the graphs. I have to show the number of successes
out of the 30 runs, but this is already set in stone, because its either
29 or 30, or its no successes.

The stocastic ensursance wants to make sure that 29 out of 30 runs are
'good enough', but combining this with the bidisectional search is difficult.
because the bidisectional search may happen to end up just higher than possible.

I considered to combine the bidisectional search with the stocastic ensurance.
But that would be way slower, and it won't be much better (or even worse depending
on how you do it) then my current implementation.


\subsection{Speed up attempts}
\subsubsection{Paralization}
Since were doing string comparisons I had the idea of ussing parlization to
speed up the algoritm by doing paralization. This can be done very easily
in scala with par collections (and the fact that imutibility is default).

However once I implemented this, I came to the conclusion it was not faster.
The overhead for delegating and creating threads was more than the parilization
gained.

The problem is that the evaluation function, even with gene length of 100, is
to cheap to make any reasonable paralization effecitve. However what was effictive
is the parilization of the expiriments. This reduced total runtime 
significantly. however this is not seen in the statistics.

\subsubsection{Evaluate each member on creation}
Members are going to be evaluated always, initially I would evaluate the member
everytime it needed to be evaluated, but in later version I just aded the
evaluation to the case class. Its not going to change anyways.

\subsubsection{Only create children if the genes are new}
If the genes are new then create the children otherwise return the parent.
This reduces evaluations and object creations. Its becomes more effective
at deeper generation, it even slows down the fastest GA's by a few miliseconds
but the deeper GA are lots faster.

This can be done safely because strings are immutable and so are the members.
So I can reuse them whenever its needed.

To reduce the amount of string comparisons, first the hascode function is called
This will cache itself, I know this because I inspected the source code of the
String class in Java.
\section{Execution}

\input{result.tex}

\section{Conclusion}
%What did I learn from my observation?
\end{document}
