\documentclass{article}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{booktabs}
\usepackage{color}
\usepackage{bussproofs}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{qtree}
\usepackage{tikz-uml}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{svg}
\newenvironment{scprooftree}[1]%
{\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
{\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }


\newcommand{\brcell}[2][l]{%
	\begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}
\begin{document}
\author{Jappie Klooster}
\title{A practical look at genetic algorithms}
\maketitle

\section{Introduction}
This is a report of the evolutionary practical assigment 1.
In here I will discuss what this assignment contained, which
methodology I used to execute the assignemnt and how the execution
went.

The intended audiance is people familiar with programming.

\section{Assignment}
The assignment was to implement the following functions and algorithms and
then do experimentation with help of these.

\subsection{Functions}
\subsubsection{Counting functions}
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}x_i\]
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}i x_i\]
\subsubsection{Trap function}
\[TF(x_1\dots x_l) = \sum^{\frac{l}{k}-1}_{j=0}B(x_{jk_1}\dots x_{jk+k})\]

with:

\[B(x_1\dots x_k)=\left\{
	\begin{matrix}
		k & \mbox{ if } &   CO(x_1\dots x_k) = k \\
		k - d - \frac{k-d}{k-1} CO(x) & \mbox{ if } & CO(x_1\dots x_k) < k \\
	\end{matrix}
\right. \]
\section{Methodology}
\subsection{Language choice}
I chose to use Scala to implement this project. The main reason being that I've
played with Scala before but never have done anything constructive with it.

Scala is both a functional and an object orientated program that runs on the JVM
It compiles to byte-code and is statically typed.

It also can use any Java library and integrates seamlessly with Java, (although
calling methods the methods of a Scala project from a Java project can be
a little clumsy sometimes, because Scala supports operator overloading in
a strange way).

Other options I considered were:
\begin{itemize}
	\item Java, which I'm very familiar with but I find quite boring to use.
		Its very verbose.
	\item C\#, the language is good but setting it up is difficult since I
		use Linux, it also has no Gradle support which makes it clunky,
		you'd have to rely on .net libraries only which is limited. It
		also prefers object orientated  rather than functional programming,
		Scala prefers functional over object orientated.
		Scala's syntax is also more concise.
	\item Rust/Go, I'm curious about both these languages, but I'm not at
		all familiar with them, so I probably should do first a little
		hobby project with them before starting doing something serious like
		this, I've already done this with Scala before.
\end{itemize}

\subsection{Architecture}
The architecture was created incrementally, I just implemented the functions
without thinking much about how to combine them.  I first started with the
fittest functions. Then I went on with selection, and finally I did the
crossover.

\begin{tikzpicture}
\begin{umlpackage}[x=0,y=0]{ec}
	\umlemptyclass[x=3]{Member}
\umlemptyclass{Population}
\umlemptyclass[x=6]{PairedPopulation}
%\umluniassoc[geometry=-|,arg1=x,mult1=1,pos1=1.9,arg2=y,mult2=*,pos2=0.2]{Population}{Member}
\end{umlpackage}
\end{tikzpicture} 

I just implemented one or 2 options of these and then created an evolution
class that accepted functions with the right prototype. So now you can
create an evolution by giving it functions.

Most of the GA architecture was already in place before the assingment became
available. I did this based on the notes I took in class. When the assignment
became available I was almost completly done with the GA. There were some bugs
in my code however and I interperted some things wrong. I also didn't write
anything for an experiment. So I still needed to do that.

\subsubsection{Unit tests}
Because the assignment has very well defined behavior. I thought it was
a very wise Idea to use unit tests. To do this I use a library called
Scala test.

\paragraph{Bugs found}
Linearly scaled reported the wrong value because it used indeci, so it
gave the first 1 a value of 0, and the second a value of 1 etc.

Trap functions were simply wrongly implemented, instead of counting the
ones they gave positional values of the ones in the block and used the
block as a lookup value for that.

Trap function actually reversed the output. I suspected the trap function
was doing it wrong because all the GA's kept failing, so I added a bunch
of very specific test for each block result which confirmend my suspicion.
The actuall bug was a simple reverse, which meant  the population, slowly
leaned towards 0's instead of 1's. and since my 'solution' is a string
of only ones, the end result is that the bisectional search kept increasing
the population size since now anwser was found and the algoritm wasn't happy.

All valuation functions should return a float instead of an Int.
I don't even understan how I could make such a stupid mistake until the
unit test pointed it out to me. (programming for 6+ years..)

\subsubsection{Build tool}
I use Gradle for building the project. Its the most advanced build platform
available and makes it easy to add dependencies to the project.
For example I use slf4j for logging.

Its also handy in that it comes with a self installing script that can be run
from any platform, Gradlew. So running the code I wrote on a different machine
becomes easy, Gradle makes sure the right dependencies are fetched.

\paragraph{Running it}

Open a shell and move to the project folder then type:

\lstset{language=Bash}
\begin{lstlisting}[frame=single]
	./gradlew run
\end{lstlisting}

\subsubsection{Libraries used}
In here I will describe why I chose to use these libraries
The details of the libraries can be found in the gradle file (which
version and what maven group):

\begin{lstlisting}[frame=single]
	cat code/build.gradle
\end{lstlisting}


\begin{itemize}
	\item The scala standart library, because I have to when using scala.
	\item slf4j, a simple logging facade, this allows runtime switching of
		logging schemes, for example if you want to log into a database or
		a file instead of stdout you can do this relativly easy with slf4j
		This is not necisary right now but the api is simple enough to use
		everywhere.
	\item scalaplot. A graph plotting library for scala. I didn't want to
		do this myself, and this library supports svg plotting and ascii
		plotting.
	\item scalatest. A testing library for scala, it has some pretty advanced
		features but I use it mostly like JUnit.
\end{itemize}
\subsection{Uncertainties}
About randomly linked:
	There is another way to do it: for every member randomly link
	differently, and randomly pick 1 randomly linked instructionset
	for offspring generation (or do the strongest).
	Currently I do the global randomly linked, every run will however
	have the same randomly linked value, I'm aware of this.

The stocastic ensursance wants to make sure that 29 out of 30 runs are
'good enough', but combining this with the bidisectional search is difficult.
because the bidisectional search may happen to end up just higher than possible.

I considered to combine the bidisectional search with the stocastic ensurance.
But that would be way slower, and it won't be much better (or even worse depending
on how you do it) then my current implementation.


\subsection{Speed up attempts}
\subsubsection{Paralization}
Since were doing string comparisons I had the idea of ussing parlization to
speed up the algoritm by doing paralization. This can be done very easily
in scala with par collections (and the fact that imutibility is default).

However once I implemented this, I came to the conclusion it was not faster.
The overhead for delegating and creating threads was more than the parilization
gained.  After 10 minutes of waiting I decided to drop this idea 
since without parilization it took about 2 minutes (I tried this
on just one run, so it shouldn't take that long).

The problem is that the evaluation function, even with gene length of 100, is
to cheap to make any reasonable paralization effecitve. However what was effictive
is the parilization of the expiriments. This reduced total runtime 
significantly. however this is not seen in the statistics.

So now all expiriments are run at the same time. This probably increases the
average time of each 'run' somewhat (not that much because the concurent
collection does \href{http://docs.scala-lang.org/overviews/parallel-collections/configuration.html}{load balancing})
It alo drasticly decreases the amount of time I have to wait. Which is quite
important, especially in the development phase. (although I also used
other tricks, such as instead of 30, just doing 3 runs)

The paralization of experiments can be removed by deleting `par' on line 64
of Main.scala

\subsubsection{Evaluate each member on creation}
Initially my members just contained the string with the `genes'. This I passed
around and would eveulate when needed. However I realized that I could do this
evaluation eagerly on creation, to reduce the evaluation calls. A member has
to be eveluated anyways, so doing this on creation and just putting in the
evaluation saves some heavy evaluation operations.

\subsubsection{Only create children if the genes are new}
If the genes are new then create the children otherwise return the parent.
This reduces evaluations and object creations. Its becomes more effective
at deeper generation, it even slows down the fastest GA's by a few miliseconds
but the deeper GA are lots faster.

This can be done safely because strings are immutable and so are the members.
So I can reuse them whenever its needed.

To reduce the amount of string comparisons, first the hascode function is called
This will cache itself, I know this because I inspected the source code of the
String class in Java.

I was very proud for coming up with  this idea, but when I ran the expirment with
and without hascode I came to the conclusion that first doing a hascode operation
significantly *slows* execution. This becomes worse as population size increases.

\section{Execution}
So I can execute in parralel, I can easily add whatever function I want, so
I decided to just run a whole bunch of experiments and see what comes out.

\input{result.tex}

\section{Conclusion}
%What did I learn from my observation?
\end{document}
