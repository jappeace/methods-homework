\documentclass{article}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{booktabs}
\usepackage{color}
\usepackage{bussproofs}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{qtree}
\usepackage{tikz}
\usepackage{listings}
\usepackage{hyperref}
\newenvironment{scprooftree}[1]%
{\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
{\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }


\newcommand{\brcell}[2][l]{%
	\begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}
\begin{document}
\author{Jappie Klooster}
\title{A practical look at genetic algorithms}
\maketitle

\section{Introduction}
This is a report of the evolutionary practical assigment 1.
In here I will discuss what this assignment contained, which
methodology I used to execute the assignemnt and how the execution
went.

The intended audiance is people familiar with programming.

\section{Assignment}
The assignment was to implement the following functions and algorithms and
then do experimentation with help of these.

\subsection{Functions}
\subsubsection{Counting functions}
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}x_i\]
\[x_i \in \{0,1\}:CO(x_1\dots x_l)=\sum^l_{i=1}i x_i\]
\subsubsection{Trap function}
\[TF(x_1\dots x_l) = \sum^{\frac{l}{k}-1}_{j=0}B(x_{jk_1}\dots x_{jk+k})\]

with:

\[B(x_1\dots x_k)=\left\{
	\begin{matrix}
		k & \mbox{ if } &   CO(x_1\dots x_k) = k \\
		k - d - \frac{k-d}{k-1} CO(x) & \mbox{ if } & CO(x_1\dots x_k) < k \\
	\end{matrix}
\right. \]
\section{Methodology}
\subsection{Build tool}
I use Gradle for building the project. Its the most advanced build platform
available and makes it easy to add dependencies to the project.
For example I use slf4j for logging.

Its also handy in that it comes with a self installing script that can be run
from any platform, Gradlew. So running the code I wrote on a different machine
becomes a trivial task, Gradle makes sure the right dependencies are fetched.

\subsubsection{Run guide}
As said before its a trivial task to run the code. Downloading and installing
of dependencies and even gradle happens automatically with help of gradlew.
So the first run is slower, depending on your internet speed.

\subsubsection{Libraries used}

\subsection{Language choice}
I chose to use Scala to implement this project. The main reason being that I've
played with Scala before but never have done anything constructive with it.

Scala is both a functional and an object orientated program that runs on the JVM
It compiles to byte-code and is statically typed.

It also can use any Java library and integrates seamlessly with Java, (although
calling methods the methods of a Scala project from a Java project can be
a little clumsy sometimes, because Scala supports operator overloading in
a strange way).

Other options I considered were:
\begin{itemize}
	\item Java, which I'm very familiar with but I find quite boring to use.
		Its very verbose.
	\item C\#, the language is good but setting it up is difficult since I
		use Linux, it also has no Gradle support which makes it clunky,
		you'd have to rely on .net libraries only which is limited. It
		also prefers object orientated  rather than functional programming,
		Scala prefers functional over object orientated.
		Scala's syntax is also more concise.
	\item Rust/Go, I'm curious about both these languages, but I'm not at
		all familiar with them, so I probably should do first a little
		hobby project with them before starting doing something serious like
		this, I've already done this with Scala before.
\end{itemize}
\subsection{Architecture}
The architecture was created incrementally, I just implemented the functions
without thinking much about how to combine them.  I first started with the
fittest functions. Then I went on with selection, and finally I did the
crossover.
I just implemented one or 2 options of these and then created an evolution
class that accepted functions with the right prototype. So now you can
create an evolution by giving it functions.

\subsubsection{Unit tests}
Because the assignment has very well defined behavior. I thought it was
a very wise Idea to use unit tests. To do this I use a library called
Scala test.

\paragraph{Bugs found}
Linearly scaled reported the wrong value because it used indeci, so it
gave the first 1 a value of 0, and the second a value of 1 etc.

Trap functions were simply wrongly implemented, instead of counting the
ones they gave positional values of the ones in the block and used the
block as a lookup value for that.
\subsection{Uncertainties}
Should the elitism selection use tournement selection?
When precisly do we find the optimal solution?
	Should I wait for convergence or just say a string
	of all ones is good enough?
	Is 1 solution good enough or should all members have
	that solution
	I'm assuming 1 solution and that I can give a string
	of just ones.
How many generations to consider. I chose arbitrarly 10.

About randomly linked:
	There is another way to do it: for every member randomly link
	differently, and randomly pick 1 randomly linked instructionset
	for offspring generation (or do the strongest).
	Currently I do the global randomly linked, every run will however
	have the same randomly linked value, I'm aware of this.
\section{Execution}
%TODO:
% 1. Experiments
%	Create tables % including:
%		* min pop size for 29 out of 30 runs successful.
%		* The average number of generations
%		* The average CPU time required for running the GA with minimal pop size
%		* average should be over 30 runs
%	Draw a graph from the experiments
%		* pop size on x, # succes on Y
% maybe some more testing of the crossovers?
% also try to implement a threading scheme??

\section{Conclusion}
%What did I learn from my observation?
\end{document}
