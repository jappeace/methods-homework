\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{pst-solides3d}
\usepackage{auto-pst-pdf}
\usepackage{tikz}
\usepackage{enumerate}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}
\begin{document}
\author{Jappie Klooster}
\title{Stay in shape! Homework exam II}
\maketitle
\section{A disk and some half-planes}
\subsection{Per case, what can you say about $H$}
We number the half-planes of $H$: $h_1, h_2,\dots,h_i$.
Let $H_{i}$ be the set of the first $i$ constraints, and
let $C_{i}$ be the feasible region defined by these constranits:

\[ H_i := \{h_1, h_2,\dots, h_i\}\]
\[ C_i := h_1 \cap h_2 \cap \dots \cap h_i\]

And so $C$ is $\cap H$.

\begin{enumerate}[(i)]
	\item \emph{There is no disk that has its centor non the $x$ axis
			that lies inside all half-planes.}

		$C$ does not intersect the x axis. So its either an empty set or entirly above or below the x axis.

	\item \emph{There lare arbitrarly large disk with the specifications.}

		$C$ has no parallel bounds to te x axis and
		at most one bounding linesegment crossing the x axis.

	\item \emph{The largest disk exists and is unique.}

		$C$ bounding linesegments cross the x-axis 2 times and
			the disk border is intersected at least 2 times by non x axis
			parralel bounding linesegments, one linesegment intersects the
			left part of the disk and another the right part.
			An alternative defintion is not case 1,2 and 4.

	\item \emph{There are several equally large largest disks}

		$C$ produces an area with one or two bounding linesgments
		parallel to the x-axis and these linesegment intersect the border
		of the possible disks.

\end{enumerate}

\newpage
\subsection{Deal with case ii in linear worstcase time}
\begin{algorithmic}[1]
	\Function{hasArbitrarlylargeDisc}{$H$}
		\State
		$b_r, b_l \gets None$
		\For{$i \gets 1$ to $n$ with $h_i \in H$}

			\If{$h_i$ is parallel to the x-axis}
				\State
				\Return $False$
			\EndIf
			\State
			\Comment{Check where the x axes crossings are, and write it into
			a variable pair, if both pairs are filled its not case ii.}
			\If{$h_i$ points left}
			\State
				$b_r \gets h_i$
			\EndIf
			\If{$h_i$ points right}
			\State
				$b_l \gets h_i$
			\EndIf
			\If{$b_r$ not equal to $None$ and $b_l$ not equal to $None$}
				\State
				\Return $False$
			\EndIf
		\EndFor
		\State
		\Return $True$
	\EndFunction
\end{algorithmic}
\subsection{Formulate and proof the RIC lemma}
\paragraph{Lemma}
Let $1 \leq i \leq n$, let $C_i$ be the defined as above and let $d_i$ be
the largest disk in $C_i$. Then we have
\begin{enumerate}[(i)]
	\item If $d_{i-1} \subset h_i,$ $then$ $d_i = d_{i-1}$
	\item If $d_{i-1} \not\subset h_{i},$ $then$ $C_i$ does not intersect the x-axis
		or $b_i \cap l_i \neq \emptyset$ where $b_i$ is the boundary of $d_i$ and $l_i$
		is the line bounding $h_i$.
\end{enumerate}
\paragraph{Proof}
\begin{enumerate}[(i)]
	\item Let $d_{i-1} \subset h_i$. Because $C_i = C_{i-1}\cap h_i$ and
		$d_{i-1} \subset C_{i-1}$ this means that $d_{i-1} \subset C_i$.
		Furtheremore,the optimal disk in $C_i$
		cannot be better than the optimal disk in $C_{i-1}$, since
		$C_i \subseteq C_{i-1}$. Hence, $d_{i-1}$ is the optimal disk
		in $C_i$ as well.
%TODO: replace with using a line between center(d_{i-1}) and
%		center(d_i) then reason about how d_i will keep growing
%		 until it hits h_i.
	\item Let $d_{i-1} \not\subset h_{i}$. Suppose for a contradiction that
		$C_i$ intersects the x-axis and that $b_i \cap l_i = \emptyset$.
		Consider the linesegment $s$ between $center(d_i)$ and 
		$center(d_{i-1})$.
		Where $center$ is a function that returns the center vertex of a disk.
		We have $d_{i-1} \subset C_{i-1}$ and
		since $C_i \subseteq C_{i-1}$, also $d_i \subset C_{i-1}$.
		Together with the convexity of $C_{i-1}$, this implies that
		the line segment $s$ is contained within $C_{i-1}$.
		Since $d_{i-1}$ is the optimal disk in $C_{i-1}$ and the optimum is to
		maximize $r_i$ the radius of $d_i$. Consider $d_i$
		where $s$ is maximized, now to increase $r_i$ we move $d_i$ along $s$,
		we can keep doing this until $b_i \cap h_i$.
		So $d_i$ needs to intersect $h_i$ otherwise $d_i$ is not the optimum
		disk in $C_i$. This shows it cannot be the case that $C_i$ intersects
		the x-axis and $b_i\cap l_i = \emptyset$.

\end{enumerate}
\subsection{Give the RIC algorithm}

\begin{algorithmic}[1]
	\Function{calculateBiggestDisk}{$H$}
		\State
		$d_0 \gets arbitrarlyLargeDisk()$
		\If{hasArbitrarlylargeDisc($H$)}
			\State
			\Return $d_0$
		\EndIf
		\State
		$H_r \gets$ random shuffle $H$
		\For{$i\gets 1$ to $n$ with $h_i \in H_r$}
			\State
			$d_i \gets d_{i-1}$
			\If{$d_{i-1} \not\subset h_i$}
			\State
			$d_i \gets calculateBiggestDiskFrom(h_i, \{h_0\dots,h_{i-1}\})$
			\If{$d_i = None$}
				\State
				\Return $None$
			\EndIf
			\EndIf
		\EndFor
		\State
		\Return $d_n$
	\EndFunction
	\Function{calculateBiggestDiskFrom}{$h_{bound}$,$H_{prev}$}
		\State
		$d_0 \gets arbitrarlyLargeDisk()$
		\For{$i\gets 1$ to $n$ with $h_i \in H_{prev}$}
			\State
			$d_i \gets d_{i-1}$
			\If{$h_i$ does not point in the same direction as $h_{bound}$}
			\If{$d_{i-1} \not\subset h_i$}
				\If{$h_i \cap h_{bound}$ does not intersect the x-axis}
					\State
					\Return $None$
				\EndIf
				\If{$h_i$ is parralel to the x axis}
				\State
				%TODO, the calculation with math?
				$d_i \gets$ Calculate the leftmost largest disk in $h_{bound} \cap h_{i}$
				\Else
				\State
				$d_i \gets$ Calculate the largest disk in $h_{bound} \cap h_{i}$
				\EndIf
				\State
			\EndIf
			\EndIf
		\EndFor
		\State
		\Return $d_n$
	\EndFunction
\end{algorithmic}

\subsection{Prove the expected running time}
It should be noted that both $calculateBiggestDisk(H)$ and
$calculateBiggestDiskFrom(h,H)$ are both linear time functions.
And so worst case $calculateBiggestDisk(H)$ is worst case:

\[O(n^2)\]

% Don't forget to remove constants
We will prove that a$calculateBiggestDisk(H)$ will run in $\Theta(n)$ expected
time with help of backwards analises: Consider the situation after $h_i$ is
inserted, and $d_i$ is computed (either by $d_i = d_{i-1}$ or with help
of $calculateBiggestDiskFrom(h_i,H)$). If $h_i$ does not bound the feasible
region, or $d_i \subset h_i$, then the addition step was cheap
and took $\Theta(1)$ time. But if $d_i \not\subset h_i$ then the addition
step was expensive.

There are $i$ half-planes that could have been defining $d_i$, and $i-2$
of these are in random order. Since the order was reandom eacho of the $i-2$
half-planes has the same probability to be the last one added, and only
$\leq$ 2 of these cause the expensive step.

Excpected time for $i$-th addition:

\[\frac{i-4}{i-2}\cdot\Theta(1)+\frac{2}{i-2}\cdot\Theta(i)=\Theta(1)\]

Total expected running time:

\[3\Theta(n) = \Theta(n)\]

\subsection{Eplain why you can't use RIC for points}
To create a RIC algorithm with linear expected time we need to have the
following properties, lets go trough each of one to see if they get violated.

\begin{itemize}
	\item \emph{The test wether the next input object violates the current
		optimum must be possible and fast.}
		This is true for this problem. Checking if a point is inside a disk
		is trivially easy.
	\item \emph{If the next input boject violates the current optimum,
		finding the new optimum must be an easier problem than the general
		problem.}
		This is the violating property. because you can still move
		the disk having a point violate the current disk may not be a point
		wich with the disks boundary has to intersect.

		A more crude way to put it is that you can have multiple optimum
		that don't intersect the same points.
	\item \emph{The optimum must already be defined by O(1) of the input
		objects.}
		I think this is true, you can use some math to figure out a new
		optimum.
	\item \emph{The analysis must work out.}
		It doesn't work out because you can't gaurantee that you've just
		found a local optimum instead of a global optimum. I mean you
		could use this as a heuristic but not as an anwser.
\end{itemize}
\section{A datastructure for horizontal line segments}

\subsection{Analyze the storage requirements}
%TODO: warning: this is x and y descisions.
\subsection{Argue that all horizontal line segs are found}
\subsection{Give psuedo code for the query algorithm}
%TODO: sla lijnen op geen punten.


\subsection{Analyze the query time}

\section{Voronoi nearest neigbour\emph{s}}
%TODO: wtf? maybe with higher order voronoi?? But it won't be log n
%TODO: we hebben ook bogen. Kun je representateren als een lijn en een punt.
\end{document}
