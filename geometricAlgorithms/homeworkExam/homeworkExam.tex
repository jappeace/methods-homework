\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{pst-solides3d}
\usepackage{auto-pst-pdf}

\begin{document}
\author{Jappie Klooster}
\title{Examination of shapes! (homework exam)}
\maketitle

\section{Polyhedron}

\subsection{When is the $xy$-silhouette of a convex polyhedron $P$ is unique}
%TODO this anwser seems to complex for 0.5 points, maybe I should look in the book
% TODO: don't give a crappy discription
%TODO: define uniqueness?
First we have to define what uniqueness means to anwser this question. I'm 
assuming uniqueness in this case means an $xy$-silhouette that can only be
generated from a polyhedron P when looking at it from a specific angle.

So when projecting a polyhedron P on an $xy$ plane (ie removing the z values).
you need to have 3 angles. $x$ rotation, $y$ rotation and $z$ rotation.

An $xy$-silhoutte is said to be unique if there is only one set of rotations
that can generate that sillhouette.

I had initially some questions about this defintion, because is it not possible
to always generate another sillouthe by just applying enough rotations.
So I started drawing a simple sillhoutte, a square with an angle.

\begin{figure}
\begin{pspicture}(-2,-2)(3,3)
\psset{viewpoint=100 0 30,Decran=100}
\psSolid[object=tetrahedron,
		r=2,
		RotZ=65,
		fillcolor=magenta!20,
        action=draw**,
		numfaces=all]%
\psSolid[object=tetrahedron,
		r=2,
		RotZ=125,
		fillcolor=magenta!20,
        action=draw**,
		numfaces=all](0, 4, 0)%
\psSolid[object=tetrahedron,
		r=2,
		RotZ=185,
		fillcolor=magenta!20,
        action=draw**,
		numfaces=all](0, 8, 0)%
\end{pspicture}

\caption{Not unique}
\end{figure}
\newpage

\begin{figure}
\begin{pspicture}(-2,-2)(3,3)
\psset{viewpoint=100 0 0,Decran=100}
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,0,0)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotZ=65,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,4.5,0)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotZ=125,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,9,0)%
	   %%%%%%%%%%%%%%%% X
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,0,-4)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotX=65,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,4.5,-4)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotX=120,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,9,-4)%
	   %%%%%%%%%%%%%%%% Y
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,0,-8)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotY=85,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,4.5,-8)%
\psSolid[object=new,
        action=draw**,
		fillcolor=cyan,
		RotY=125,
		numfaces=all,
        sommets=
		0 0 2
		-1.5 -0.1 0
		1 -1 0
		1.5 2.5 0,
   faces={
       [0 1 2]
       [0 2 3]
       [0 3 1]
       [1 3 2]}](0,9,-8)%
\end{pspicture}
\caption{Unique}
\end{figure}

I did applied similiar rotations for the $x$ and $z$ axis. If you
do both 180 degrees you end up looking at the same side. So for this
particiluar figure there exists a unique $xy$-sillhoutte.
\newpage
\subsection{Give an algorithm that detrmines an $xy$-silhouette of a conves polyhedron $P$ in O(n) time}
\begin{algorithmic}[1]
	\State
	\Comment{Helper function to suffice the contract (init work)}
	\Function{findxySilAlgoirthm}{$v_{start}$}
	\State
	\Comment{Find the border of the silloutte}
	\State
	%TODO 
	$\vec{e}_{init} \gets IncidentEdge(\Call{findxyBorderFirstImprovment}{v_{start}})$
	\State
	\Comment{The $Seq$ just makes an arbitrary sequence with constand append time}
	\State \Return
	\Call{findxySilhoeutte}{
		$Origin(\vec{e}_{init}), \vec{e}_{init}, Seq(\vec{e}_{init})$
	}
	\EndFunction
	\State
	\Comment{Finds the xyBorder by maximizing X}
	\Function{findxyBorderFirstImprovement}{$v_{start}$}
		\State
		\Comment{The incident is used to check when we've traversed all edges}
		\State
		$\vec{e}_{incident} \gets IncidentEdge(v_{start})$
		\Repeat
			\State
			$\vec{e}_{next} \gets Next(Twin(\vec{e}_{incident}))$
			\State
			$v_{candidate} \gets Origin(Next(\vec{e}_{next}))$
			\If{$v_{candidate}$ has bigger x than $v_{start}$}
				\State
				\Comment{The return statment will break the loop}
				\State
				\Return \Call{findxyBorderFirstImprovement}{$v_{candidate}$}
			\EndIf
		\Until{$\vec{e}_{next}$ is equal to $\vec{e}_{incident}$}
		\State
		\Comment{If the loop finds no improvment we've maximized X and are on the border}
		\State \Return $v_{start}$
	\EndFunction
	\Function{findxySilhouette}{$v_{start}, \vec{e}_{current}, S_{result}$}
	\State
	\Comment{Base case, passing the start all the way down doesn't require us to do marking}
	\If{$v_{start}$ is equal to $Origin(\vec{e}_{current})$}
		\State \Return $S_{result}$
	\EndIf
	\State
	\Comment{Figuring out which edge to do next}
	\State
	$\vec{e}_{next} \gets Next(\vec{e}_{current})$
	\State
	\Comment{We use another recursive funtion for this}
	\State
	$\vec{e}_{next} \gets \Call{findLeastRotatingEdge}{Twin(\vec{e}_{current}), Next(Twin(\vec{e}_{next})), \vec{e}_{next}}$
	\State
	\Return \Call{findxySilhoeutte}{
		$v_{start}, \vec{e}_{next}, S_{result} \cup \vec{e}_{current}$
	}
	\EndFunction
	\Function{findLeastRotatingEdge}{$\vec{e}_{start}, \vec{e}_{current}, \vec{e}_{best}$}

	\Comment{Trying to get an as shallow rotation as possible}
	\If{$\vec{e}_{current}$ rotation is bigger than $\vec{e}_{best}$ (with as orientation point $Prev(\vec{e}_{start})$)}
		\State
		$\vec{e}_{best} \gets \vec{e}_{current}$
	\EndIf
	\State
	\Comment{Base case for recursion}
	\If{$\vec{e}_{start}$ is equal to $\vec{e}_{current}$}
		\State
		\Return $\vec{e}_{best}$
	\EndIf
	\Comment{Going deeper because there is another step}
	\State
	\Return \Call{findLeastRotatingEdge}{$\vec{e}_{start},Next(Twin(\vec{e}_{current})),\vec{e}_{best}$}
	\EndFunction
\end{algorithmic}

Because the Polyhedron $P$ is convex (so no weird dents), and
the initial vertex $v_{start}$ was already on the boundry this
alogrithm is correct.
In class we used marker bits but its simpler to just pass the
starting point, less chance to shoot yourself in the foot with
mutable state.

\subsection{Why takes this algorithm linear time}
To determin this lets go over the function and see how much time they each
maximally can take.
To start the algorithm you call FindXYSilAlgorithm and pass it a starting
vertex. Then to find a boundary of the XYsillhoute the
FindBorderFirstImprovement is used. This tries to maximize X to ensure we
are on the border of the sillhoutte. It takes any improvement, so it may
not take the shortest path, but at most it will take $O(N)$ time.

After the border is found we pass it 
\section{Red and blue lines}
\begin{algorithmic}[1]
	\State
	$P_{ends} \gets R \cup B$ (flat) Mapped to endpoints where each segment
	produces two end points, the endpoints contain a reference to eachother
	and they aslo contain which color they are.
	\State
	$P_{sorted} \gets P_{ends}$ sorted on Y coordinate.
	\ForAll{$p_{current} \gets Next(P_{sorted})$}
	\EndFor
\end{algorithmic}

The status of the sweep line is a set of linesegments intersecting it at
its current position. ordered from left to right (x axis).

\section{Polygon cut}
\section{Diagonal polygon cut}
\end{document}
