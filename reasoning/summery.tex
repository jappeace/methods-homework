\documentclass{article}
\usepackage{txfonts}
\usepackage{booktabs}
\usepackage{color}
\usepackage{bussproofs}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{qtree}
\usepackage{tikz}
\usepackage{listings}
\usepackage{hyperref}
\newenvironment{scprooftree}[1]%
{\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
{\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }

\begin{document}
\lstset{language=Java}
\author{Jappie Klooster}
\title{A Summery about reasoning with logic}
\maketitle

\section{Introduction}
This summery is written for people that try to understand logicians on a master
level *but* they're comming from `hbo informatica'

\section{On proofing things}
If you were lucky like me you'll be asked to write a proof in the first week
which will be graded. I got a terible grade, but learning I did.

So there are 2 kinds of proving. The first one is writing a proof in the system
this should be rather easy, although you have to be carefull to follow the
rules to the letter. I'm going to ignore this one since its just using the
rules, which you've done tons of times as a programmer, so it shouldn't be
that strange. Although I'm making an exception for Hilbert and Grammar,
Hilbert isn't that obvious and Grammar isn't obvious either.

The second one is the more troublsome, its proving the system itself. This
is also split up into 3 different aspects. They all have in commen that
it should be done in natural langauge. But, there is a structure to it
I'm going to try and give a complete overview of this structure.

First you have soundness, then there is completness, these are both just
properties of a system, so there are many more things to proof, but these
are some of the most important because they decide if a system is usable.

\subsection{functions}
Proving things is sometimes done with a function,
now you should be familiar with functions.
But they are defined in natural langauge, which may seem a little starnge
so as an example I'll define the valuation as first time I came accross it:

\[v:\mathcal{F}_{prp} \to \{0,1\}\]

the prototype in Java is like this (I assume you never can be sure of course,
see \autoref{notations}):


\begin{lstlisting}[frame=single] 
	public boolean V(Formula f);
\end{lstlisting}

Now in logic you describe the datatypes in natural langauge, so first they will
say `let', `define' or ` v is a function' \ldots

The other function I came across was the I function. Which stands for 
interpation, what it does is just replacing the commas for the propper
connectives.

\section{proving soundness}
This basically means your system doesn't modify the value you put in.
If you put in truth, apply a bunch of rules from your system, then you should
get out truth.

The technical defintion is: The argument should be valid and all
its premisses are true. Premisses in a system are the axioms.
So they should be valid (valution function returns 1). The arguments
in a system are the rules, so they should at least preserve truth.

\subsection{Structure of your proof}
First write down your overal strategy of the proof \autoref{strategies}. For
soundness this is often `proof by induction' \autoref{induction}.

Then write down the lemmas you're gonna use. A lemma is a little proof, often
derived from the properties of the system you're proving. You could see it
as a basic argument. When proving soundness you want to connect this to the
semantics, for propositional systems the semantics are truth tables, for kripke
models it are kripke frames. The semantics are the thing your talking about
in your logical system.
%I can see how I dind't understand all this crap the first time I saw it,
% its freaking packed with definitions, and even if you understand all the
% definiontions, its still hard
Make sure that you've proven the soundness of the axioms *and* of the rules
with help of the semantics.

Finally ty up the lemmas together in the conclusion, this is done with help
of the proofing strategy.

Finish with a sentence like: `This had to be shown'.

\section{proving completeness}
Every validity should be proofable in the system. So there is usually no 
obvious way of proving this, but for the system treated in the course
there are some 

\section{proving strategies}
\label{strategies}
There are many different ways of writing proofs, in here I'll sumerize the ones
I came accross during the course.

\subsection{Induction}
\label{induction}
In here you try to prove something by starting with a single case n.

For all n (*), n=1, supose (*) for n, then show (*) for n+1.

So you start with an assumption, usually based on the question.
For example \emph{show that if $\vdash_x A$ then A is a bird.}

So you start with the base case, ie: \emph{We assume that $\vdash_x A$}
You can do this because of propositional logic, whenever you see
if x then y or x implies y you can just assume x. Continuing:
\emph{Which means there is a proof $A_1,\ldots,A_n$ of A}.
Here you're just saying that because A is part of X, there consists
a bunch of steps that lead to A. \emph{We prove$A_i$ is a
`birdlike property' with induction to $i$} Here you're saying
that the steps that lead to A have all `birdlike properties' (or whatever
property you're using) and you're gonna use induction to show that.
\emph{As $A_n = A$ this implies A is a `birdlike poperty'}

Now you're using the properties of the system and you call them lemmas.
These are the arguments and you connect them to the semantic.
\emph{Lemma 1, we have to proof that all axioms are `birdlike properties'
	This is done by showing with help of the semantics of x, in case of
system x this is a sleeve.
Bellow you can see the sleeve of axiom D which clearly indicates that
axiom D is birdlike
}

\[sleevefigure\]

\emph{For axiom Z you can also see its birdlike:}
\[(slightly altered) sleevefigure\]

You do this for all the axioms.

The next lemma is about the rules, these also have to be shown to keep
track of birdlikeness in system x:

\emph{Lemma 2, all the rules of x preserve birdlikeness:
	For the rule argument ad hominum, supose that the precedents
	are bird like
}
Precedents are the stuff you put into the rule.
You can supose this because you've already shown in lemma 1 all the axioms are
birdlike, so for the induction step it can't be anything else.
\emph{
	With the following sleeve it is shown that not under all valuations 
	birdlikeness is preserved, but only for the ones were birdlikeness was
	already there
}
\[(uninteresting) sleevefigure\]

\emph{this finises the proof for lemma 2}

Now the final step of induction is doing the induction step with help of the
just proven lemmas.

\subsection{tabloo or truth tree}
In this strategy you create a tree, starting from the axioms which is either
true or false, you go down step by step and say what happens. In most systems
if one of the axioms is false it means the conclusion is false to.

\section{notations}
\label{notations}
There is no standart in notating things. Every logician seems to use a
slightly different notations. Keep this in mind. But I think the connectives
are mostly the same. You probably need to memorize these.

\noindent
\begin{tabular}{@{}lll@{}}
Symbols&
In natural language &
Technical name \\ \toprule
$\neg$ 			& not 				& negation \\
$\wedge$,\& 	& and 				& conjunction \\
$\vee$ 			& or 				& disjunction\\
$\to$	& if \ldots then 	& implication\\
$\leftrightarrow$	& if and only if 	& equivalent\\ \bottomrule
\end{tabular}


Then there are some other symbols used:

\noindent
\begin{tabular}{@{}ll@{}}
Symbols&
In natural language \\ \toprule
$\vdash$ 					& Part of system, ie, is derivable \\
$\vdash, \Rightarrow$ 		& Seperator between antecedent and succedent\\ \bottomrule
\end{tabular}


\section{Systems}
\begin{itemize}
	\item $H$  Hilbert, has a huge set of axioms, and only 1 rule. (also called fredge)
	\item $CPC$ Clasicial Propositional logic, formulas in here are always true
(tautologies)
	\item $GKC$ Gentzen calculus, also called sequent calcules
	\item $GKC_K$  Getnzen + R 
	\item $GKP$ Genzen + structural rules.
\end{itemize}

\section{Proving in Hilbert}
Hilbert is the most simple system. However because of its simplicity proving
things in it isn't very obvious. There are multiple ways of writing proovs

\section{Proving in Grammar Logic}
Grammar logic is a (failed) attempt to make sense of natural langauge. It
tries to organize words into types, and groups of those words into compositional
types.
Connection words such as ` that' will have complex types.

\end{document}
