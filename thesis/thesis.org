#+TITLE: A serious communication game with personalities
# Pure functional serious communication in-game
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper, drafting]

#+Options: toc:nil ^:nil 
#+Options: title:nil
#+OPTIONS: H:5

#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \renewcommand{\bibsection}{}

#+LATEX_HEADER: \usepackage[obeyFinal, colorinlistoftodos]{todonotes}
#+LATEX_HEADER: \newcommand{\drafting}{\todo[noline, color=gray]{Working draft}}
#+LATEX_HEADER: \newcommand{\toReview}{\todo[noline, color=yellow]{To review}}
#+LATEX_HEADER: \newcommand{\underReview}[1]{\todo[noline, color=olive]{Under review by #1}}
#+LATEX_HEADER: \newcommand{\newlycleared}{\todo[noline, backgroundcolor=white, bordercolor=red]{Newly cleared}}
# (something cleared that was under discussion last time)
#+LATEX_HEADER: \newcommand{\cleared}{\todo[noline, color=white]{Cleared}}

# Title page
#+LATEX: \input{title}

# The order of this thesis will be done in a way to let future researcher
# decide the value of the thesis quickly
# 1. First the abstract to let a researcher quickly discard this thesis if neccesary.
# 2. The toc, to let a researcher jump to interseting pages quickly.
# 3. The introduction and main body of the thesis. If all else fails a
# reaserhcer can use this as fallback

# smaller code font size (cause mostly boring xml)
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}
** Abstract                                                          
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_CENTER

\todo[inline]{abstract}

#+END_CENTER
\todo{keywords}

\todo[inline]{Read: The art of dialogue 2006, center of applications of psycology type}
\newpage
#+TOC: headlines 2

\newpage

* Introduction
\cleared
Communication is the foundation of our modern society.
Having good communication skills can help individuals in both professional as
well as in their personal lives.
However training people in communication skills can be difficult.
Another party is required to communicate with,
and a tutor or teacher has to be there to give feedback.
Serious games can be used to train people with these kind of skills
cite:swartout2013virtual.
Therefore a general "communicate!" game was developed.
Wherein teachers can create scenarios to let their students practice with
communication cite:jeuring2015demo.

\cleared
This game was script based, the teacher made a scenario and the student would
follow the choices predefined by the teacher.
A script based game has of course the weakness that a student can't use
creative responses,
all possible responses are scripted into the scenario
and replying correctly relies on a simple /abc/ choice.
To combat this an alternative serious game was made based on the
chatbot Alice cite:weiderveld2016chatbot.
To measure performance a rule engine was used, and to limit the domain
to that of a doctor's appointment social practices were used.
In this thesis we are interested in extending this work with personalities,
where we consider personalities to be a preference for a process rather than
content cite:campos_mabs2009.

\cleared
Since the personality topic has become quite popular in recent years
some thoughts will be devoted to related work.
After that,
to validate our work according to personality research
we'll look at existing personality theories and their advantages and disadvantages,
keeping practical considerations in mind.
Then we'll have a look at idiomatic AI programming and how in theory personality
could be combined with AI.
We continue by taking a close look at the state of the existing software that
we're planning to extend.
After this we'll discuss the implementation.
Finally we'll compare the different implementations.

** Related work
<<Related work>>
\cleared
  To simulate personality in communication games there have been already several
works proposed.
Etheredge used the OCEAN personality theory to create argumentative
agents cite:etheredge2016personality.
Although argumentation is not the same as communication we can consider the
method used to make the personality.
In this paper a personality model is introduced based on OCEAN.
To move from personality values in OCEAN towards action selection fuzzy logic
is used.
However this has a major disadvantage in that a lot of rules need to be
added to do action selection.
This can make action selection opaque.
It is for example not immediately clear how a higher anxiety will influence
action selection.
Having a lot of rule also make maintenance hard, if for example there is an
unwanted behavior many rules need to be inspected before the change can be made.

\cleared
In agents with with personalities cocu tried making a complete game based
on MBTI cite:cocu2015agents.
However communication was never implemented and personality got reduced to
doing a single action.

\cleared
Van den bosch also chose to use OCEAN to model characters in a serious
communication game cite:van2012characters.
He used a nested probabilistic if else structure to decide on how agents should
interact.
His methodologies had some shortcomings however,
for example a not agreeable person was defined as someone who'd had a high
probability of telling facts about himself.
Which in certain situations could be considered strange,
for example a spy who was captured.
This kind of methodology is called content orientated cite:campos_mabs2009,
the personality, would and should change depending on context.

\cleared
Campos used the MBTI to create BDI based agents cite:campos_mabs2009.
We will use a more fine grained version of MBTI but his architecture is used,
in which personality will be processed orientated rather than content
orientated.

* Background

\cleared
In this chapter we will discuss the work that is the foundation of this thesis.
First we will look at personality theories developed by psychology.
Then we will look at some to the literature in AI and argue for the
methodologies used,
and finally we will look at the serious game in its existing form.

** Personality theories
   \cleared
   A personality is a set of identifiers that can be used with
   reasonable consistency to predict behavior
   cite:mischel2008introductionp3_definition.
   What we want from this model is a guideline of implementation for the program,
   that is to say,
   the more the theory says about internal workings of a person the better it is.
   We want it to model to be realistic of course,
   but we also want it to be implementable.
   This is where we have a conflict of interest with the field of
   psychology since they do not necessarily care about implementation details.

   \cleared
   This conflict of interest can be seen for example in
   cite:mischel2008introductionp4_defpoints, where a criteria of personality is
   that it should be stable and coherent. However this is a poor
   software specification since there is no unit of measurement
   (how long should it be stable, and what range is acceptably stable),
   but for psychology it is a good definition, because a human can determine out
   of context what these things are.

   \cleared
   The field of psychology has been somewhat active in trying to model human
   personality cite:pervin2008handbook. 
   Several frameworks have been developed to figure out people's
   personality and what this in turn would mean for their lives.
   We are interested in two ways in existing personality theories:
   1. Accuracy, if a personality thoery does not fit the reality at all it won't
       help anyone in the serious game.
   2. Ease of implementation. If the personality theory is too hard (or impossible)
       to implement in the serious game than we can't use it.
   The field of psychology is very interested in the first requirement. 
   However the second requirement not so much.
   Therefore our first job will be to list existing psychology personality
   frameworks,
   and filter out those that are unfeasible to implement.


*** The big five
  <<OCEAN>>
 \cleared
 The first framework we'll discuss is called the big five.
 The term big five first coined in 1981 by Goldberg cite:goldberg1981language.
 The big five were not big because of their intrinsic greatness,
 but rather to emphasize how broad these factors were.

 \cleared
 This framework was not really invented, but rather discovered trough
 lexical analyses by for example Tupes cite:tupes1961recurrent.
 Although the labels used were different,
 they conveyed the same idea as the big five model used now.
 The methodology used is something which is called factor analyses[fn::
 In the paper the term 'varimax rotational program' is used,
 but if we look this term in wikipedia, we can see the result is called factor
 analyses cite:varymaxrotanonalprogram].
 Factor analyses is a statistical methodology that tries to find underlying
 hidden variables.
 This methodology has become widely used in psychology cite:fabrigar1999evaluating.

 \cleared
 The data Tupes used is from Catell cite:cattell1947confirmation and several
 others. Catell used a rating scheme,
 where a trait was introduced and all test subjects then had to rate all other
 test subjects else as average, below or above average for that specific trait.
 Persons could also use one extreme rating per trait for one person.
 These traits in the test were based on the /personality sphere/ concept which
 tried to cover the entire surface of personality by providing many small trait
 areas.
 Examples of the traits are: "Attention getting vs Self sufficient", or
 "Assertive vs Submissive".

 \cleared
 In the begining of the 1990's there were many ways to measure personality that
 didn't agree with each other.
 For example at Berkley alone block used a 2 dimensional ego-resilience and
 ego-control method cite:block1980role,
 whereas Gough measured folk concepts such as self-control, well-being and
 tolerance cite:gough1987california.
 Personality researchers hoped that they would be the one to discover a structure
 that would then be adopted by other researchers cite:pervin2008handbookp114.

 \cleared
 The goal of the big five was not to present a new structure that convinced
 others to use it,
 but rather to provide a taxonomy that all psychologist could agree upon.
 Since the big five was so broad (because of the statistical methods used),
 this worked.
 Therefore the researchers could keep on exploring there niche with their
 proffered structure,
 but once they would present their work they could use the big five to
 communicate clearly what their research meant without having to redefining the
 words every time cite:pervin2008handbookp114..116.

 \cleared
 The big five as in the OCEAN definition
 has the following units of measurement:
 - Openness or originality, if you score high on this you enjoy learning new
   things just for the sake of learning. If you score low then you don't enjoy
   this
 - Conciseness, how tidy you are, if you score high the dishes don't stack up
   in the sink.
 - Extroversion, a high score indicates you enjoy leading the conversation and
   you'll speak up when you disagree with someone.
 - Agreeableness or altruism, a low score would indicate that you don't want to
   share and generally don't trust people.
 - Neuroticism or nervousness, a high score indicates that you like to brag and
   get upset when someone is angry at them.

 \cleared
 The big five has been extensively tested and the result has been replicated
 in multiple studies cite:pervin2008handbookp119.
 One can measure his big five score trough a test called the NEO-PI, or the
 NEO-FFI. The FFI variant is shorter but less precise cite:costa1992revised.

 \cleared
 Although these terms may provide a great taxonomy,
 it does not have any theoretical foundation cite:eysenck1992four.
 This means it becomes difficult to speak about implementation.
 To make this more clear we use a thought experiment:
 Lets say you have a score of 0.8 for Neuroticism,
 how does this influence my decision for selecting action $a$ or $b$?
 Now you could say, use a mixed strategy where in you choose 80% of the time
 the neurotic typical neurotic approach.
 Then we need a valuation function to decide which of the two actions is more
 neurotic.
 But once we've done this we still haven't taken into account any of the
 other factors.
 Solving this is a non-trivial endeavor.

 \cleared
 There are some existing solutions in which OCEAN is implemented, for
 example allbeck used it as a mapping to the EMOTE system cite:allbeck2002toward,
 whereas cite:durupinar2008creating used the OCEAN values as a low level mapping
 in steering behaviors
 and finally cite:etheredge2016personality used the values for action selection
 in a dialogue, but extended the descriptions of OCEAN with IPIP
 with an entire chapter devoted to explaining this.
 Although these implementation are based on the same OCEAN model,
 the influence of it has starkley different effects on their
 respective implementations.
 Since each of them decided to change the OCEAN model in some kind of way
 we can conclude that although OCEAN is good for discussing the psyche,
 it is incomplete for a software specification role. 
 
*** Personality types
 <<sec:types>>
 \cleared
 To address the big five's issue of having no thoeretical foundation we'll
 have a look into personality types.
 We begin with the theoretical foundation proposed by the grandfather of
 personality research, Carl Jung.
 After which we'll look at a thoeretical evolution proposed by Myers and
 Myers-Brigs, which also introduced a structered method of measuring types.
 Then we'll discuss some critique on this method.
 With this critisim in mind we'll look at alternatives to the MBTI that have been
 proposed afterwards.

**** Jung's theory of psychological types
<<Jungian types>>
 \cleared
 Jung describes several concepts, firstly each person has two attitudes:
 /Introversion/ and /extroversion/.
 Extroversion means dealing with the outside world and therfore is called
 objective (or observable).
 Intoversion is the world inside a person, and therefore is subjective,
 or private.
 This privacy however may bo so great that the consiouness can't even access it.
 These attitudes are mutually exclusive,
 you can't do introversion and extroversion at the same time.
 For example if you're day dreaming you're not paying attention to your
 surroundings.
 A person who spends most of his time in the introversion attitude is called
 an /introvert/.
 But he is not totally the one or the other, ie an introvert can still have
 extravert moments and vice versa.
 It should also be noted that the unconsciousness according to Jung is
 flipped in attitude. cite:hall1973primer97-98attitude

 \cleared
 Then there are four functions.
 The first two functions are called the /rational functions/
 because they act as a method of making judgements.
 /Thinking/ is a function that connects ideas with each other to arrive at
 generalizations or conclusions. 
 /Feeling/ evaluates ideas by determinging if its good or bad, pleasant
 or unpleasant, beautifull or ugly.
 Note that this is /not/ the same as being emotional,
 although you can be emotional and use this function.
 The /irrational functions/ are called this becuase they require no reason.
 /Sensation/ is sense perception created by the stimulation of the senses,
 it can always be rooted to a sense,
 such as "I see a balloon" or "I feel hungry".
 /Intuition/ is like a sensetion but its not produced by a sense.
 Therefore it has no origin in the same way as sensation has,
 by which its explained as "just a hunch" or "I feel it in my bones".
 cite:beauchamp2005communication,hall1973primer98-100functions

 \cleared
 To use these functions they have to be combined with attitudes, producing
 /function attitudes/.
 Therefore a person will never be of a thinking type,
 but rather either a thinking introvert or thinking extrovert.
 cite:hall1973primer100-101combo
 We can now imagine what this means,
 an extroverted thinker will for example make judgement about the real world,
 and therefore be more like a natural scientist or biology researcher,
 where they would study natural objects and behaviors.
 An introverted thinker will make judgement about ideas in his mind,
 and therefore will be an excellent philosopher, or mathematician, where
 consistency of the internal reasoning process is important.

 \cleared
 Let $\mathcal{J}$ denote the set of all possible jungian function attitudes
 such that:
 \[ \mathcal{J} = \{ T_e, T_i, F_e, F_i, S_e, S_i, N_e, N_i\}\]
 Where
 + $T_e$ stands for extraverted thinking, which is thinking about objects in the
   real world. This is thinking with a goal, a problem to solve,
   to check weather certain laws are upheld, or a system to check.
   As said before a typical example of $T_e$ based reasoning would be a
   biologist studying natural behavior.
 + $T_i$ stands for introverted thinking,
   this kind of thinking could be called deductive,
   it tries to construct a framework to explain the world.
   This is consistent reasoning based on internal believes,
   which does not necessarily solve a problem.
   A typical example of $T_i$ based reasoning is a mathematician creating or
   combining new mathematical structures with help of axiomatic logic.
 + $F_e$ stands for extraverted feeling, where objective or external criteria
   is used to judge, for example something is beautifull or ugly.
   Established standards may be used to decide this and therefore its a
   conservative function.
   Decisions are based on interpersonal and cultural values.
   A typical example of $F_e$ based reasoning is about fashion and fads.
   Deciding what is fashionable at the moment is an $F_e$ based process.
   A typical profession would be working at a clothes shop,
   where the knowledge of the latest trends is crucial.
 + $F_i$ stands for introverted feeling, decisions based on personal values and
   believes.
   People who have this as dominant function attitude could be characterized by
   "still waters run deep".
   A typical profession for this type is in counseling or health care, because
   empathy comes rather natural to them cite:fiproffesionadvice.
 + $S_e$ stands for extroverted sensing, Act on concrete data from the here and
   now. Then lets it go.
   People of this type are often realistic and practical.
   A typical profession driver of heavy machinery or athlete cite:seproffesionadvice, 
   because living in the moment is most important for those professions,
   this comes natural to $S_e$ based personalities.
 + $S_i$ stands for introverted sensing, acts on concrete data from memories and
   passed experience.
   A possible profession for the people with $S_i$ as dominant function is in
   quality assurance,
   where the perfect model in their mind can be easily
   compared to the product in question cite:siproffesionadvice.
 + $N_e$ stands for extraverted intuition, try to find possibilities in every
   situation.
   Extroverted intuition can be very good entrepreneurs, seeing ideas in
   almost every situation,
   they also makes them very inspiring leaders because
   they are very excited about their ideas cite:neproffesionadvice.
 + $N_i$ stands for introverted intuition. Looks new possibilities in ideas.
   A typical occupation of this type is artist or visionary
   cite:hall1973primer104nitype,
   this is because connecting ideas with each other comes natural to this type.
   However just like the typical artist it may not always be understood why by
   his peers or even himself.

 \cleared
 <<Jungian alternating functions>>
 Another important concept is the idea of the /principal/ and /auxilirary/
 function cite:hall1973primer105principal.
 The principal function is the one that is most preffered.
 The auxilirary renders its services to the principal function,
 however this function cannot be the opposite of the principal.
 So if /Feeling/ is the principal function than thinking connot be the auxilirary.
 This is also true for the irrational functions.

**** MBTI
 \cleared
 The meyer brigs type indicator is based upon Carl Jung's theory of personality
 types.
 However it brings two important changes, first of all the way
 of measuring personality type is changed. 
 It uses a strutured approach rather than Carl Jungs projective approach.
 The responses to items are finite and therefore can be deduced based on theory.
 In contrast to Jung's technique where he used open ended answering with word
 associations cite:hall1973primer23method.
 Then there is the introduction of an extra index used to order function
 attitudes cite:carlson1985recent.
 Which is either a $J$ for judging (rational in jung terms)
 or a $P$ for perceiving (irrational in jung terms).
 This dimension indicates together with the $I/E$ dimension which function
 attitude is dominant and which is auxilirary.

 \cleared
 <<sec:mbti:order_comparison>>
 Once completed with the MBTI you'll get charatcter string as outcome,
 for example "INTJ".
 This label tells you inderectly which of carl jung's functions is dominant,
 auxilirary, tetriary and inferior cite:mccaulley2000myers.
 In other words it provides a sequence of preferences
 cite:website.mbtitypedynamics.
 In case of INTJ it would be:
 \[N_i > T_e  > F_i > S_e\]
 So the most preffered function to be used by someone of type INTJ would be $N_i$,
 then $T_e$ and so forth.
 These are the same function as Jung used, the MBTI
 just imposed an order on them cite:mccaulley2000myers,website.mbtisequence.
 How much preference there is for a function is not encoded in MBTI, just an
 order of preference.
 An ENTJ would be simialar to INTJ but with a different order:
 \[T_e > N_i > S_e > F_i\]
 With this definition the interplay of the judging/perceiving dimension becomes
 more obvious if we look at INTP: \[T_i > N_e > S_i > F_e\]
 It's similar to an ENTJ, but the attitudes have flipped.

 \cleared
 A possible grouping of the sixteen type exists using the middle letters:
 \[\{NT, ST, NF, SF\}\]
 This grouping goes under the rationale that the first two functions only
 differ in either attitude, order or both.

 \cleared
 Before continuing we would like to say a word about a popular
 interpertation of MBTI which is based on Kersey's book "Please understand me",
 and later "Please understand me II".
 In this interpertation the sixteen types are also placed in general groups
 of four but here the $ST$ and $SF$ distinction is replaced by $SJ$ and $SP$
 cite:keirsey1998please.
 It turns out however that Kersey invented this distinction because
 "He thought it made sense to group them this way" cite:whyaretypesdistinct.
 In doing this he rejected the work of Jung and also that of cognitive functions.
 Which is problematic because the theory he presented then does not make any
 thoeretical sense.
 Therefore Kersey's MBTI will not be used in this thesis.

 \cleared
 The MBTI is extremly popular in a subfield called Organizational Developement
 (OD) cite:sample2004myers. 
 But it has gotton some heavy critism in from the field of psycology.

 \cleared
 MBTI has always used a continues scoring system in the results.
 However the creators insist that type is enough for making assessment judgments.
 Since MBTI reduces the test scores to type,
 it is expected that most of the population would fall into either proposed
 dimensions.
 For example $I$ or $E$.
 This is called a bimodal distribution.
 However cite:bess2002bimodal suggests this is not the case,
 but this could be the result of the scores being biderictional
 cite:salter2005two.
 In an extended investigation cite:arnau2003jungian into weather jungian
 constructs are truly categorical suggested however that this was maybe not
 the case and a continues scale for assessment judgements are required.

 \cleared
 In cite:sipps1985item the MBTI is put trough a method called factor analyses.
 This is the same technique where OCEAN is based upon (see section [[OCEAN]]).
 With this technique the desired outcome is that there are 4 question clusters
 (or factors), one for each dimension.
 These factors should also be independent,
 a question that influences I/E score should not influence S/N.
 Finally we expect the factors to indicate differences between individuals.
 Random questions won't do that.
 However the study indicated that the MBTI had more than 4 factors (6),
 cite:sipps1985item explains the first extra factor as questions that assessed
 people being "unconditional positive",
 but could not explain the other extra factor.
 Something else of note worth cite:sipps1985item indicated was that there
 were questions doing no discrimination at all (not being scored). 

 \cleared
 Reliability indicates how often the same result will come out of the test,
 for example if you take the mbti a 100 times you may be classified the same
 type for 70 times,
 which would be an indication it has a reliability of arround 70%.
 But in psycology another aspect is important,
 namely the interval in between which the tests are taken,
 if for example two tests produce starkly different results but a long time
 has passed between them its not considered a big issue.
 In cite:pittenger1993measuring it is suggested that after a period of 5 weeks 50%
 of the participants changed in score.
 However one should take into consideration that after taking the test a first time 
 people could consciously decide to change their opinion because they think its
 more desirable to have a different type.
 Jung said that type is decided very early on in life cite:hall1973primer106inborn
 so having reliable scoring is important.

**** PPSDQ
 \cleared
 The PPSDQ keeps basically the same theory as MBTI cite:kier1997new,king1999score,
 but uses a different measuring method.
 Instead of forced questions it uses a word-pair checklist for
 $I/E, S/N$ and $T/F$, and for the $J/P$ self describing sentences are used
 cite:melancon1996measurement.
 An example of a word pair checklist can be found in table [[tab:word-pair-example]].
 The word pairs themselves were obtained by prescribing an exploratory test(s) to a
 sample in which the proto PPSDQ was submitted and also the MBTI itself, factor
 analyses was used to determine correlation, this is done in
 cite:thompson1994concurrent.
 The optimal amount of points (options to choose from)
 presented in such a test is a subject for debate.
 Common sense would suggest that more points would give more precision,
 but in cite:matell1971there it is suggested that reliability and validity
 do not increase with more points. In cite:garland1991mid however they
 state the importance of an available midpoint.
 The 5 point choice format in the PPSDQ is not motivated.
 
#+CAPTION: An example of a word pair checklist, where the test taker should choose the  word that he identifies most with
#+NAME: tab:word-pair-example
 | Word          |   |   |   |   |   | Word      |
 |---------------+---+---+---+---+---+-----------|
 | Empathy       | 1 | 2 | 3 | 4 | 5 | Logic     |
 | Dispassionate | 1 | 2 | 3 | 4 | 5 | Emotional |

 \cleared
 The result of the PPSDQ would look something like: I-30 N-20 T-80 J-60, with
 a scale of 0 to 100. To calulate the jungian functions as a probability measure
 some math is required. Our subject is $70\%$ of the time introverted and $30\%$ of the 
 time extroverted. $60\%$ of the time judging and $40\%$ of the time perceiving.
 therefore N_i would be calulated as: 0.7 \times 0.4 \times 0.8 = 0.224 or $22.4\%$.
 N_e would be $0.3 \times 0.4 \times 0.8 = 0.096$ etc.
 From this you can make a preference sequence or create a mixed strategy.

 \cleared
 The PPSDQ is measuring the same thing as MBTI but lacks the critisms of MBTI.
 The reliability is for example between 90% to 95% with a delay of two weeks.
 The internal consistency was also measured which proved to be better than
 MBTI but there was still a dependency between S/N and P/J which remains
 unexplained cite:kier1997new.
 The PPSDQ is internally most consistent of the discussed alternatives
 (excluding OCEAN) cite:arnau1999alternative.

**** SL-TDI
 \cleared
 SL-TDI measures functions by presenting 20 situations and then giving subject
 possible actions which corrolate with the functions.
 The subjects then have to indicate how likely it is that they would choose that
 particular action cite:arnau2000reliability.

 \cleared
 It becomes rather staight forward to make a function preference of the 
 measurement of SL-TDI since the qeustion directly measure the jungian
 functions.
 A possible personality type therefore would be:
 \[ S_i \geq T_i \geq S_e \geq F_e \geq N_i \geq T_e \geq N_e \geq F_i \]
 To determine the preference we just used the observed value in the test.
 Since every situation offers a choice for each function with a 5 point value
 there is no need for normalization.

 \cleared
 This denotion is much less strict than the MBTI or PPSDQ since it does not force
 alternating attitudes or pairing of rational/irrational functions in the
 preference.
 Therefore the amount of personality types SL-TDI supports drastically exceeds
 that of the PPSDQ. In other words, there always exists a mapping from PPSDQ
 to SL-TDI, but not always from SL-TDI to PPSDQ.
 The reason for doing this is because there is experimental evidence
 that there exist personalities outside of the stucture orignally imposed by
 MBTI and the subsequent PPSDQ cite:loomis1980testing.

*** Comparison of theories
 \cleared
 To re-iterate, we are interested in a framework that is realistic, and easy to
 implement.
 The Big Five falls short on the easy to implement,
 there is no underlying theoretical framework to support it cite:eysenck1992four,
 therefore we cannot base our implementation on anything except our own
 interpertation.

 \cleared
 The MBTI has been criticized a lot from the field of psychology,
 but it does have a solid theoretical foundation.
 There is some relation between the big five and MBTI cite:furnham1996big.
 Therefore its somewhat realistic, but quite easy to implement.

 \cleared
 Both of the alternatives of MBTI use a continues scale and have a high
 correlation with the big five cite:arnau1997measurement.
 This means is that they are measuring something which is also measured by the
 big five in some way.

 \cleared
 The PPSDQ is based on the same thoery as MBTI, but with scaled type letters.
 To convert the type to function attitudes some extra work has to be done,
 namely calulate their respective probabilities.
 To decide which function attitude to use some kind of mixed strategy
 has to be used.
 The PPSDQ is more realistic, but at the cost of being more difficult to
 implement.

 \cleared
 The SL-TDI is even harder to implement than the PPSDQ because the function
 attitudes no longer have to alternate.
 This either means that functions are independent (thereby rejecting some of Jung's work),
 or that they have to work in some kind of combination.
 If they work in some kind of combination and we have to following preference:
 \[ T_e > T_i > S_i > N_i > F_e > N_e > S_e > F_i\]
 We select the first function to work with, but it requires some information now,
 what to do?
 Select $S_i$, thereby skipping $T_i$, or select $T_i$ and let it decide to
 select $S_i$, but this would basially give $T_i$ censorship rights.
 This is difficult to answer therfore it is a lot more difficult to implement
 than PPSDQ.
 Since SL-TDI drops an assumption, which is shown with experimental evidence
 to be false cite:loomis1980testing, we can say SL-TDI's theory is most realistic.
 This comes however at the cost of being even more difficult to implement.

 \cleared
 Therefore our preference for implementation is the following:
 \[ \text{MBTI} > \text{PPSDQ} > \text{SL-TDI} > \text{OCEAN} \]

 \cleared
 There is another hidden reasoning behind this, the work of PPSDQ can built on
 that of MBTI, and that of SL-TDI can build on that of PPSDQ.
 OCEAN builds on nothing, we'll leave that for future work.

** Artificial intelligence literature
 # How do I measure that the persnoality created is in fact in complience with
 # the personality I aimed for?
 # Can I let the personality take the test somehow?
 \cleared
 In this section we will look at some of the AI based literature.
 For example we will have a look at the intelligent agent approach and the BDI
 architecture.
 We will also look at some theoretical attempts at implementing personality.
 Theoretical attempts are often a logic in contrast to the topics
 discussed in [[Related work]] which include executable implementations.

*** Agents background
 \cleared
 In the literature there is little consensus on what exactly an agent is,
 however there is a general consensus that an agent is /autonomous/
 cite:wooldridge2009introduction.
 To make this more clear we'll use Wooldridges' definition:

 #+BEGIN_QUOTE
 An /agent/ is a computer system that is /situated/ in some /environment/ and
 that is capable of /autonomous action/ in this environment in order to meet its
 delegated objectives. -- Wooldridge
 #+END_QUOTE

 \cleared
 In another older definition cite:wooldridge1995intelligent Wooldridge highlights
 /autonomy/, /social ability/, /reactivity/, and /pro activity/.
 Where autonomy means that no human intervention is required,
 social ability means it can talk to other agents,
 reactivity is that it can reply on input and pro activity means that it can
 show behavior while not reacting to something.
 However he later continues on with a stronger claim about an agent is a
 piece of software that uses concepts which are attributed to humans.
 Such as believes desires and intentions.

 \cleared
 This is the reason why we can't call any program an agent.
 For example an operating system kernel is
 autonomous (a user would never interact with it),
 social (can do networking),
 reactive (it will comply to hardware interprets for example)
 and proactive (a process hogging to much memory will be killed without the
 process asking for it).
 However we won't call a kernel an agent because it doesn't even come close to
 having believes, desires or intentions.

 \cleared
 Something to keep in mind is that there are three "branches" of agent research
 cite:wooldridge1995intelligent.
 The first one is /agent theory/ in which /specifications/ and methods of 
 specifications are developed. They ask what are agents and what are they
 ought to do and how do we tell them that.
 Then there are the /agent architectures/, these address questions of how
 to implement the specifications written by the theorists.
 In this paper we won't discuss architectures since we work in an existing
 system described in section [[The serious game]].
 Finally there are the /agent langauges/, which ask the question how to write
 agent programs.
 Again this is mostly preditermined for us, but we will give a small overview.

**** Belief desires and intentions
 \cleared
 The belief desire intention model of human practical reasoning was first
 introduced by bratman cite:bratman1987intention.
 It is based upon a "common sense" framework of human reasoning.

 \cleared
 The idea of BDI is that an agent has believes, these can be anything, such as
 I believe the grass is green, or I believe the keys are on the table.
 Note that we never speak about facts, an agent can believe something to be a
 fact, but that doesn't make it a fact.
 Desires are special kind of believes that give agents a reason to be, they
 may also be called goals.
 Intentions are (partial) plans to make a desire come to fruition.
 How to formalize this properly turns out to be a hard question, which is
 analyzed in the following section [[bdi logics]].

 \cleared
 A number of reasons have been stated to use this methodology.
 The foremost is to make agent orientated systems less expensive in maintenance,
 verification and construction according to Rao and Georgeff cite:rao1995bdi. 
 However they don't cite a source for this.

 \cleared
 Another paper argues in favour of agent orientated design cite:jennings2001agent.
 It has the following major arguments:
 It is effective to divide a complex problem domain into several smaller problems,
 abstracting in an agent orientated way is more "natural",
 and complex systems dependencies and interactions can be easily modeled.
 # A case study is presented as proof of these claims.

**** Logic of BDI
 <<bdi logics>>
 \cleared
 \todo[inline]{We can delete this paragraph if we don't have any connections with these things. We may use it by saying for example that beliefs have certain kind of modalities. We probably aren't gonna use it to prove theoroms for example}
 Logic of BDI is an attempt to formalize how agents behave.
 One of the first formalization of Bratman's theory was that of Cohen and
 Levesque cite:cohen1990intention. It was based on linear time logic and
 used operators for actions and modalities for goals and beliefs cite:meyer2014logics.
 It was also used a tiered formalism, with at the bottom belief goals and
 actions which provided the basis for the higher achievement and persistent goals
 and intentions to do and be.
 Rao and Georgeff introduced a different formalism that used branching time logic. 
 They use modal operators for belief desires and intentions and then put 
 constraints on them to make interactions meaning full cite:meyer2014logics.
 Therefore this formalism is much closer to that of bratman cite:rao1991modeling.
 Finally there is the KARO formalism which is based on dynamic logic.
 This is the logic of actions and computation. They extend this logic with
 epistemics to add believes to it cite:meyer2014logics.

**** Concrete implementation
2apl, jade cite:braubach2003jadex.
 \todo[inline]{Comment on adding this was: If the work becomes agent like, and we have some very clear commanalities between 2apl for example we can fill in this paragraph to fall back onto that}
 \todo[inline]{Perhaps it would be a good idea to sketch commanalities between drools and these kind of things, so that if a reader knows about any of these things he can lay the link easily}
*** Social practices
 <<social practice>>
 \drafting
 In cite:smolka2001social it is stated that the research in activity theory
 led to the development of social practices.
 It was Karl Marx who made the roots who thought of the "roots" of activity
 theory cite:engestrom1999perspectivesp3_marx,
 Activity theory tries to bridge the gap between a single actor and the system
 it resides in cite:engestrom1999perspectivesp10_broad_definition
 trough the activity in progress.
 Another way of describing activity in this sense is "a way of doing things".
 A problem with this model however was, how do cultures move activities from the
 collective towards the individual cite:smolka2001social.
 Social practices were therefore introduced to make the notion of activity more
 concrete. As Smolka put:

 #+BEGIN_QUOTE
 ... [The social practice] requires the intimate articulation of forms of action
  and forms of inquery.
  It anchors knowledge production and the theorizing and analysis of
  institutional and intervention practices within the actual conditions of
  human development. -- Smolka
 #+END_QUOTE
 
 So by using a social practice you have to think about forms of action and
 questions that may be asked. 

 \drafting
 It ten got criticism from ...
 \todo[inline]{critques on social practices? To show potential weaknesses}

 \drafting 
 But then X showed they were ...
 \todo[inline]{come back social practices, why these weaknesses are not a problem}
 
 \todo[inline]{How do different personalities interact with this, for example does an INTJ have a different plan pattern than an ENFP? Is there research about this?}
 \todo[inline]{SP's are a shortcut so that we can assume 2 agents think about similiar things, its not a restricting concept but rather a facilitating concept to allow agents to do less reasoning because of common assumptions.}
 \todo[inline]{There is a connection between this and culture (perhaps I can cite this from somewhere)}

 \toReview
 To limit the domain of the application a theoretical device is used
 called social practices.
 This gives an ordered overview in what domain our program should work.
 In other words, rather than some extra element, it will be the
 /foundation/ of the program cite:dignum2014contextualized.
 We can formulate therefore the social practice that is relevant for this thesis 
 in the following way:

 + Practice name: Doctor appointment
 + /Physical context/, \todo{As an example we expect sensing personalities to check if everything fits before assuming the SP whereas intiuitve may fill the gaps}
   - Resources: Computer, chair, diagnostic tools..
   - Places: waiting room, doctor's office...
   - Actors: doctor, patient, assistant, ...
 + /Social context/,
   - Roles: Doctor, Patient...
   - Norms: doctor is polite, patient is polite, doctor is inquisitive
   - Social interpretation: Can sit on chair, cannot sit on table.
 + /Activities/, share information, do diagnostics, minor treatments,
   prescribing drugs...
 + /Plan patterns/, Introduction \to ask complaints \to gather history \dots \todo{These are not concrete plans but rather patterns that still have to be filled in}
 + /Social meaning/, awkwardness, gratitude, ...
 + /Competences/, Give injection, empathetic talk

 If the social practices however are defined more formally they could be 
 used in a bigger system such as in cite:augello2015social and
 cite:augello2016model.

*** BDI + Personality
 \cleared
 \todo[inline]{other proposed systems and argue for campos}
 Campos discussed an architecture in which personality emerged not from things
 you like,
 but rather than trying to determine which content a personality preferred,
 the personality was encoded in the process they preferred.
 This was called /process orientated/ rather than contend orientated.
 cite:campos_mabs2009
 For example in their interpretation of MBTI a Sensing agent would make a plan
 in complete details whereas an intuitive agent would just continue planning as
 needed.
 Thinking agents would base their decision process upon their own believes
 whereas feeling agents would consider what other agents want.
 In our model we conceptualize the Jungian functions also as a process.
 We comment more on this in section [[Jungian BDI]].
 
** The serious game
 <<The serious game>>
 \cleared
 This chapter describes the game we inherited from our predecessors.
 We have to discuss precisely what they did for two reasons:
 1. To help understand the design constraints we work under
 2. To distinct our changes from theirs'

  \cleared
 There have been several distinct versions of the "communicate!" game. 
 The first version was a web based game, with a scenario editor.
 cite:jeuring2015demo
 However it had some drawbacks,
 for example each dialog was scripted by the teacher and the answers the student
 could give were specified by the teacher.
 This made practicing on it somewhat unrealistic.
 Practicing in this case would mean memorising what button to click rather
 than to figure out what to say.

 \cleared
 To address this issue the a new implementation was made. 
 This version was based around the idea of a chatbot, in the form of the ALICE
 bot.
 The AIML language was extended to allow emotional reactions of the agent.
 This new langauge was called S-AIML cite:augello2016model. 

 \cleared
 A specific scenario was created for doctor/patient interaction     
 cite:augello2015social.                                            
 The game in this version also has the ability to judge the skills practiced
 cite:augello2016social,
 such as following certain protocols (politeness, medical standards), and empathy.  

 \cleared
 There is a difference between the architecture in the published papers and
 the source code received. In cite:augello2016social the judgement of these
 practices was for example encoded within the S-AIML langauge,
 however in the source code AIML has taken a step back
 It is only used for processing and not deliberation
 (which is now being taken over by drools as discussed in [[existing architecture]]).
 We will be using the source code as a guideline in discussing the existing
 work because it is more relevant.

*** Functionality
    \cleared
 There are two major functionality perspectives to consider,
 that of the student, and that of the teacher.
 We will consider these in separate subsections since in game they
 don't interact.
**** Student usage

    \cleared
 For a student to use the application he has to first start a client.
 He can now choose to start a new game.
 There are options to list existing games but these have not been completed.
 Once in game the user enters a screen as can be seen in [[fig:client]]:
  #+CAPTION: Client view
  #+NAME:   fig:client
  [[./img/client.png]]

    \cleared
From here the student can start practicing, the game will track his progress
on the server.
**** Teacher usage
    \cleared
For the teacher there is right now no client.
The way a teacher can setup a scenario is trough modifying AIML and drool files.
The teacher probably needs an expert to do this since these are right now
combined with the war.
It would be difficult to modify these files on a running instance.

*** Abstract architecture
\toReview
A conceptual abstract architecture was already in place and described very well
by cite:augello2016social. This can be seen in figure [[fig:abstract-architecture]],
which was directly taken from cite:augello2016social.
 
  #+CAPTION: Abstract architecture as described by cite:augello2016social
  #+NAME:   fig:abstract-architecture
  [[./img/abstract-architecture.png]]
  
\toReview
The interaction module handles user interaction, where the GUI can show the
dialogue and the mood of the agent.
The Dialogue module inside it however handles low level string interpretation
with help of AIML (see [[Text Processing]]), this basically works trough string
matching.
Note that although represented in the abstract architecture as the same module,
the GUI resides in  the implementation on the client side whereas the dialogue
module resides on the server.

\toReview
The dialogue module calls directly the Representation and interpretation module
with help of specialized tags (see [[Deliberation]]) information can be inserted in
the representation and interpretation module.

\toReview
Both the 'representation and interpretation' module and the score module use
drools to do their respective tasks.
The only real separation in implementation is trough directory and file
structure, but at runtime there is little distinction.
The only other oddity is the direct connection between the emotion module and
the GUI, this is because the emotion module sends directly messages to the GUI
whilst ignoring all of AIML.

*** Application Architecture
<<existing architecture>>
    \cleared
    The game uses a client server architecture (see figure [[fig:components]]).
    The client is written in unity and the server is a Java servlet running on
    wildfly.
    Communication between the two applications happens trough a web socket.
    A web socket is used because it allows the chatbot to pro-active,
    which is not possible with a technology such as REST.

#+NAME: fig:components
#+BEGIN_SRC plantuml :file img/uml/components.png :exports results
[Unity Client] <--> Websocket : json
[Wildfly java servlet (server)] <--> Websocket : json
#+END_SRC
#+CAPTION: Component diagram of the application
#+LABEL: fig:components
#+RESULTS: fig:components

**** Source tree
    \cleared
    There are two major source trees tracked in separate version control systems.
    The first manages
    the client[fn::received on commit 40b55c0da1f556ba2b66ea8322d72008c9df1e72]
    and the second the
    server[fn:: received on commit 92f12fc26a7da83554903bfe7c6ed1cc64dd5a53].
    The protocol is tracked separately in the respective client and server
    folders with the folder name "dto".

**** Protocol
    \cleared
    The protocol is setup to be intended for a much larger system.
    There are hints of a registration system but further inspection
    revealed that only logging in only worked and but was required.
    This is tied into the server's ability to run multiple games. 
    there is also a limited monitoring functionality, the active games can
    be listed with a specialized message.
    A typical happy path scenario of protocol messages is listed in
    figure [[fig:sequence]].

#+NAME: fig:sequence
#+BEGIN_SRC plantuml :file img/uml/sequence.png :exports results
  actor client
  entity server
  client -> server : login(userid,password)
  client -> server : newGameRequest
  server --> client : newGameResponse(idNewGame)
  client -> server : startGame(idGame)
  server --> client : log(text)
  == Chat start (example) ==
  client -> server: userUtt(text)
  server --> client: agentUtt(text)
  server -> client: agentUtt(text)
  client --> server: userUtt(text)
#+END_SRC
#+CAPTION: Sequence diagram of a typical game
#+LABEL: fig:sequence
#+RESULTS: fig:sequence

\newpage
**** TODO User utterance processing 
     text here

\todo[inline]{Should also do a message processing activity diagram since we want to compare it against that}
*** Server architecture
  \cleared
We will discuss the server architecture in more detail since it contains the
"brains" of the application.
The most important classes are shown in figure [[fig:class]].
WebSocket is the entry point for the program where the messages from the client
enter.

#+NAME: fig:class
#+BEGIN_SRC plantuml :file img/uml/class.png :exports results
  interface ChatBotEngine{
    +String chat(String request)
    +void setSession(Session session)
  }
  class ChatBotEngineImpl {
    -KieSession kSession
    -Chat chatSession
    -Session session
  }
  ChatBotEngine <|-- ChatBotEngineImpl
  class WebsocketService{
    -ChatBotEngine cbe
    +void onMessage(Session session, String message)
    -void chat(Session session, Strin message)
  }
  WebsocketService --> ChatBotEngine

  package org.kie.api.runtime{
  KieSession <-- ChatBotEngineImpl
  class KieSession{
      +Facthandle insert(Object obj)
      +void setGlobal(String identifier, Object value)
  }
  }
  package org.alicebot.ab{
  Chat <-- ChatBotEngineImpl
    class Chat{
      +HashMap<String, Object> predicates
      +String multisentenceRespond(String str)
      +setKieSession(KieSession kie)
    }
  }
#+END_SRC
#+CAPTION: Class diagram of the server, where kie is the engine that handles the drools
#+LABEL: fig:class
#+RESULTS: fig:class

\cleared
The Websocket uses a ChatBotEngine to determine how to reply to userUtterences,
Where ChatBotEngineImpl is the concrete implementation.
ChatBotEngineImpl uses a KieSession for the drools and a Chat which is the alicebot.
Once the startGame message is received the kie service is started,
which runs on a dedicated thread to do drool deliberation.
At this point facts can be inserted for the drools to react upon, in case
of the anmnesi scenario the GameStart fact was inserted, which was a marker
object to indicate that the game has started.
This allow drools to take the initiative, for example when the user
hasn't replied after 20 seconds the agent will ask the user why he hasn't
replied yet.
A detailed overview of construction can be seen in figure [[fig:construction]].

\cleared
In the class diagram (figure [[fig:class]]), we can see an attribute to the Chat
class called predicates.
This is a bag of variables the drools can use to keep track of the scenario
progression.
The setGlobal method of KieSession is used to expose global objects to drools.
In this case the ChatBotEngineImpl is exposed.
Insert can be used to insert facts.
The difference between facts and globals is that facts are evaluated by
the  rule base, where as globals are used by the rule base.
A fact can be considered as "just a value".
Currently globals are used as communication with external libraries
(for example the websocket and chat session).

#+NAME: fig:construction
#+BEGIN_SRC plantuml :file img/uml/construction.png :exports results
|WebSocket|
start
:Receve StartGame message;
:Construct a chatbotengine;
|#CCDDDD|Engine|
:Start kie thread;
:Register engine as controller in kie;
:Insert GameStart fact;
|#AntiqueWhite|Drool|
:Load aiml files;
:Construct a Chat object with help of AIML;
:Chat inserted in controller;
:Log to client;
|WebSocket|
:put game id in websocket user prefs;
stop
#+END_SRC
#+CAPTION: Activity diagram of a server game construction
#+LABEL: fig:construction
#+RESULTS: fig:construction

\newpage
**** Text processing
<<Text Processing>>
    \cleared
     Text processing is done with help of the ALICE chat bot.
     This bot does the parsing and validation of AIML,
     with help of the knowledge encoded in AIML it can specify a response.
     For example:
#+BEGIN_SRC xml
	<category>
		<pattern>
			What is the problem
		</pattern>
		<template>
			<srai>why are you here</srai>
		</template>
	</category>
	
    <category>
		<pattern>
			* why are you here
			</pattern>
		<template>
			<srai>why are you here</srai>
		</template>
	</category>
#+END_SRC
\cleared
     In this example the first category indicates that if a user types
     "What is the problem" (pattern tags), then the answer can be found in a
     category with pattern "why are you here".
     The second category does the same but the star indicates that any
     characters before the pattern can be ignored to satisfy the category.

**** Deliberation
<<Deliberation>>
\cleared
     AIML has been extended to allow updating of the drools knowledge base:

#+BEGIN_SRC xml
<category>
    <pattern>why are you here</pattern>
    <preconditions>not healthProblemAsked</preconditions>
    <template>
        <insert packageName="sp.anamnesi.health_problem" typeName="HealthProblemAsked" />
        I'm experiencing a <getDroolsTemplate />. It's quite strong.
    </template>
</category>
#+END_SRC

\cleared
     In this case if a user utters the sentence: "why are you here", the bot
     will check the drool database what his problem is and also update the
     scenario.
     Once the scenario is updated the possible responses of the chat bot are
     changed, as can be seen by the precondition tag.
     The template tag has some extra tags. The insert tag inserts a fact into
     the drools knowledge base, the getDroolsTemplate tag queries the drools
     knowledge base for a string.

* BDI and Jung
\todo[inline]{Describe what  am I doing in this chapter?}
\todo[inline]{We can make an analogy of type towards puzzle pieces, and the thing I'm doing with function combination is just a chain of puzzle pieces that fit together, where the unit is a straight end and the input is left open until there is a user meaning input}
\todo[inline]{Add an image of architecture, recoginition section (currenlty aiml), delibiration section (perhaps on 3 levels, this is where personality can come in), mk sentence section (go from meaning to string)}
\todo[inline]{Explain why I want to replace the chatbot, (because there is currently no way to stop it from reacting to something, and since its mostly an xml parser I think its just easier to replace with a new system (also xml is bad?))}
<<Jungian BDI>>
\drafting
In this chapter we will consider how to combine Jungian psycology with BDI,
as was originally done by Campos cite:campos_mabs2009.
We will reason about Jungian function attitudes by considering the
type signature of a pure function that can represent them.
A Haskell like syntax is used for this.
We want to have a type signature that can describe the domain,
but nothing more, to keep the project as simple as possible.
Note that a simple function can be infinitely complex because it can have an
infinite number of arguments and an infinite number of results in a tuple,
this is of course not desirable (or possible).
Another issue which is discussed is where this function is supposed to be placed. \todo{Except this isn't done yet}
Finally We will also look at how to convert user utterances to objects we can do
reasoning with.

\cleared
There are some differences from the theory discussed in [[sec:types]] and Campos'
process.
The difference is that in the discussed theory we would translate MBTI to the
underlying Jungian functions, whereas Campos used the measured dimensions.
Translating to the functions has some advantages,
by doing so we are for example not bound to just the MBTI.
We also get more accurate descriptions of what Jungian functions are,
Jung described in his work people with that particular function as dominant.
This is harder to do with the dimensions, because if you take an INTJ type and an
INTP type the semantics of both the N and T change because of the P/J dimension, 
as can be seen in their respective order (see [[sec:mbti:order_comparison]]).
Campos avoids this by ignoring the I/E and J/P dimensions, resulting in a
simplified theory.
However we would like to note that it is not an easily extendable simplification.
Therefore we chose to translate types to orders in Jungian function attitudes,
something which is already done by MBTI (see [[sec:mbti:order_comparison]]).

\cleared
Another consideration to make is what are these function attitudes?
By which I mean what do they represent in computer science terms: progams,
objects or functions? What should they be?
Since Jung wasn't much of a mathematician cite:jungonfunctions its just an
informal definition.
However we can make a mapping to certain BDI processes
based upon their description,
but before that is done we need to make several structural observations.

\cleared
Firstly functions attitudes are not independent, by which I mean that
if we have a function attitude $a$, followed by $b$ then the resulting
behavior is different than $b$ followed by $a$ (see [[sec:mbti:order_comparison]]).

\cleared
Secondly all functions should be used and their order matters.
The first function used should be most prevalent.
This means that we can't just execute all functions and use a do preference
selection on the result.

\cleared
We will interpret the Jungian functions as a mapping from an agents believes
and senses towards an agent action and new believes.
This is then reduced to the scope of a chatbot in the social practice.
After this we will look what extra information the function attitudes need
in an attempt to reduce the amount of possible believes.

** A type signature approach
\cleared
To give a more deep understanding of the scope of this project we will
try to come up with a type signature of a pure function that models all the
function attitudes.
This is done with a Haskell like syntax (or category theory), \todo{cite the haskell and category theory?}
in which the arrows indicate a function,
left of the arrow is called a domain and the right side a codomain.
The domain is also the argument of a function.
If we see a pattern like $a \to b \to c$ means $a \to (b \to c)$ or give an $a$
and return a function $b \to c$, this process is called partial application
cite:haskellpartialapplication.
Capital letters indicate sets.

\cleared
To make this process more easy to understand we'll postpone modeling interplay
between the $f_a$ function attitudes and define a type signature for them working
individually.
To do this we will define some terms, with which we will go from the broadest
definition possible towards one that just fits the project scope.

\cleared
Let $\mathcal{B}$ denote the set of all
possible believes and let $B_t$ with $B_t \subseteq \mathcal{B}$ denote the
believes of an agent at time $t$. 
$\mathcal{S}$ is the set of all possible sense information, in which $S_t$
with $S_t \subseteq \mathcal{S}$ denotes the sense information of an agent at
time $t$.
$\mathcal{A}$ denotes the set of all possible actions with $A_t$ with
$A_t \subseteq \mathcal{A}$ denoting the set of actions executed by the agent at
time $t$.
With this definition we can define every possible agent configuration as the 
following pure function type signature
\[ B_t \to S_t \overset{f_a}{\to} (B_{t+1}, A_{t+1}) \]
This says, we first put in the current believe base, then the sensory
information after which we get a new believe base and a set of actions.
In this the intentions are encoded in the function used, and the desires are
part of the believe base.
We marked the $f_a$ arrow, which indicates the deliberation process of the agent,
so $f_a$ can be any of the function attitudes.

\cleared
This definition is however too general for our domain.
First of all the set of sensory information can be reduced to a String,
since this is the information we get from a user.
However a String is still to broad since going from a textual representation
to a deliberation process is difficult.
Therefore we will introduce another mapping function $g$:
\[ \sigma \overset{g}{\to} m \]
Where $\sigma$ is a string and $m$ a meaning where $m \in \mathcal{M}$ in which
$\mathcal{M}$ stands for the set of all encoded meanings.
Conversely  there is another function $g'$:
\[ m \overset{g'}{\to} \sigma \]
This allows meaning $m$ to decoded into string $\sigma$.
Note that in this relation there can be multiple $\sigma$ that map to the same
meaning, but one meaning always produces one string $\sigma$.
In the previous version this mapping was entirely done by AIML.
How this is done in this version will be discussed in the implementation
section [[From strings to meanings]].

\cleared
So the simplification is now as follows,
firstly we note that $\mathcal{M} \subset \mathcal{S}$,
since understanding meaning is a form of sensation.
Then we can define $M_t \subseteq \mathcal{M}$ which stands for the meanings
the agent received at time $t$.
To ensure a reactive and proactive we also have to pass the current time
as argument.
This allows the agent to do deliberation without having received a meaning
(ie an empty set).
This produces the following type signature:
\[ B_t \to t \to M_t \overset{f_a}{\to} (B_{t+1}, A_{t+1}) \]

\cleared
$\mathcal{A}$ is also to broad in definition.
For our domain we are not interested in every possible action.
Instead we just want to have another meaning as output,
since these correspond to strings. 
Therefore we constrain $\mathcal{A}$ by introducing yet another set
$\mathcal{R}$ which stands for the set of a possible reply messages,
or the replies encoded by the programmer.
In this case $\mathcal{R} \subset \mathcal {A}$ since replying to something is an
action.
Now we can define $R_t$ with $R_t \subseteq \mathcal{R}$ which is a set of
replies at time $t$. This produces the type signature:
\[ B_t \to t \to M_t \overset{f_a}{\to} (B_{t+1}, R_{t+1}) \]

\cleared
We have some believes, time and meaning going in, some deliberation
going on and a new set of believes and replies going out.
The new believes can be used for the next iteration.
However this type signature isn't enough.
The current agent has to be able to do a game tree like deliberation process
to reason about what the other agent will say so it can pick the meaning that
brings it closest towards its goal.
In our case a goal is a particular meaning the agent wants the doctor to utter,
for example if our agent is sick we want the doctor to utter a /GiveMedicine/
meaning,
or if he is in extreme pain he would like to see the /GivePainKiller/ meaning
uttered.

\cleared
Therefore we introduce $D$ a dialogue tree:
\[ D = (m, [D])\]
Where $m \in \mathcal{M}$ for the meaning,
and $[D]$ is the ordered list of dialogue children.
The initial dialogue just has a meaning with an empty list of children.
A reply would be the same except with a list of children that is bigger than zero.
The most preferred reply is the first element in the list of children.
With this in place we can model the following type signature:
\[ B_t \to t \to D_t \overset{f_a}{\to} (B_{t+1}, D_{t+1}) \]
So we receive a dialogue tree from the user, which can just be a root node,
and then we put out a dialogue tree plus the replies which are the children.

\cleared
Now we should note that this type signature heavily constrains our agent.
It for example can't handle being punched in the face by the doctor unless
there is a meaning encoded for that. 
It also runs into trouble when the agent is asked to sit on the counter.
Movement should be possible, but movement like one does during sky
diving is not interesting because we have the informal constraint of the
[[social practice]].
However once movement becomes a requirement we can just create a new function
type signature that is less restrictive, but still has the option to use these
functions for meaning full replies.

*** Composing type dynamics
\cleared
The first thing a commendable programmer may think of when trying to combine
behavior is of course functional composition.
However there is an important requirement for this to work.
The input type and output type need to be the same of the two functions we
want to combine.
Our current type signature has this feature almost except for the time
argument, it is not difficult to work around this.
What is problematic however is that using functional composition in this
way would make it impossible for function attitudes to inspect results
of their auxiliary functions.
This is an important feature we want to keep because if for example a
judgement function is first in the order of functions and receives
the user meaning it can't do its job yet, more on his in this section
[[Rational and irrational]].
Therefore we consider another approach.

\cleared
In this approach we will give $f_a$ another argument which is the next $f_a$.
This looks like the following:
\[ \left (\overset{next}{B_t \to t \to D_t \to (B_{t+1}, D_{t+1})}\right ) \to B_t \to t \to D_t \overset{f_a}{\to} (B_{t+1}, D_{t+1}) \]
Note that the function in the next bracket has the same prototype as the codomain.
In this case the /next/ function can play an advisory role to the codomain.
A unit function can be defined that produces empty sets as results for both
believes and action.
By unit function we mean the initial /next/ function.

\cleared
To illustrate the use of this type signature design more clearly we'll sketch
an example with the first two function attitudes of the INTJ type:
\[N_i > T_e \]
So to encode this as a function we start with the least preferred function
attitude namely the $T_e$,
however to let it play an advisory role in the $N_i$ function we first
need to complete the /next/ argument.
Because its the least preferred function we just use the unit.
Now the partially applied type of $T_e$ satisfies that of $N_i$ and we can use it as
/next/.
This methodology can be used for an entire personality type (ie all 8 functions
in some order)

\cleared
With this methodology function attitudes can decide themselves to consult the
next type.
Then they can inspect the result, and even the changed believe base to decide
if its a good idea to use the result.

\cleared
This architecture can be extended with the scale based jungian models
such as SL-TDI and PDQ by introducing a random choice for using the current or
next function.
However this becomes rather messy because we're modeling pure functions,
therefore we leave this as an exercise to the reader.

***  Rational and irrational cardinality
<<Rational and irrational>>
\cleared
Up till now we have modeled the type signature have consumed sets meanings and
produced sets of replies.
However we ignored cardinality.
If we look at the definition ([[Jungian types]]) of rational and irrational,
we can make a design decision about the cardinality.
Rational functions are about making decisions therefore it should
consume one or many meaning and produce only one reply,
irrational are about producing information therefore it should consume
one meaning and produce many.

\todo[inline]{either say what a reply is in the dialogue tree or rewrite to use the dialogue tree}
\toReview
Modeling this idea into type is however easier said than done.
There are problems with this.
Lets say the primary function is an irrational one.
Now we give it a meaning from the user and get out multiple replies.
How do we decide which should be used?
Or if it is an rational and we give it a single meaning how should the
rational function get multiple meanings to make a decision upon?

\toReview
To solve this problem we will apply an order to the replies.
The highest in the order will be the most preferred reply and the lowest the
least preferred.
This results in the following conceptualized architecture:
/rational/ functions change the order of replies,
/irrational/ increase the number of options.
So if we start with an irrational function it produces several related meanings
to the inputted meaning in a tree like structure.
The original meaning uttered by the user as root node and the produced response
meanings as children.
These then get inserted into the next rational function which modifies the order
of the children. After doing this it passes this structure to the next
rational functions (because they alternate [[Jungian alternating functions]]),
until all functions in the personality had their chance.
The unit function then makes a reply of this meaning (ie choosing the highest
ordered child) which then returns trough all functions that can still modify it.
This could happen if a rational function was the first function for example
and didn't have any choices available to decide upon.
This structure still works with SL-TDI's non alternation.

** Mapping function attitudes to a process 
<<Mapping to process>>
\toReview
Now you may argue at this point we haven't refined our types a lot, since
the believe structure was defined as "Every possible believe",
which is basically analogous to "Anything you can think of" or in a Object
Orientated terminology: Object.
Since the believes serve as input of our function and output of the function
we may as well have said $Object \to Object$.
Of course the believes are not intended to be true output but rather just
part of the mind. ie the believes are intended to be kept in a container
whereas the input $M_t$ and the output $R_{t+1}$ would only be visible for the
"outside world".
But still we want to refine our all possible believe to something which is 
less broad in scope.
To do this we will start analyzing the Jungian functions and see what
"extra" information require to function to perform their duties.

\toReview
So $T_e$ uses just one ply in the meaning tree and then applies a static
evaluation to determine if uttering a certain meaning will get it closer
to its goal (its more like a heuristic).
$T_i$ uses alpha beta pruning on the meaning tree to
determine the best goal. Therefore both $T$ functions don't need any
additional information to perform their processes.

\toReview
Both $F$ functions need a valuation function $h$:
\[ m \overset{h}{\to} i \]
where $i \in \mathbb{N}$.
The encoding of this system is similar of the existing work on /drools/.
Since they included mostly value based scoring.
To illustrate the difference between $F_e$ and $F_i$ we can use different
strategies.
$F_e$ could try to model what the other agent values by performing fictitious
play cite:berger2007brown,
whereas $F_i$ could use satisficing play cite:stimpson2003learning.
The intermediate results of the plays can be written into the believe structure.
However doing this may be difficult since the games aren't completly
repeated (the actions may differ per deliberation cycle),
therefore as an easier alternatives we can make two variants
of $h$ that produce group values and personal values.

\toReview
N uses a meaning graph where $N_e$ goes breath first and $N_i$ goes depth first.
So $N_e$ produces the results of connected meanings of the input meaning,
but $N_i$ creates a deeper tree, using the /next/ function to decide
where to go on crossroads.
Alternatively reinforcement learning can be used $N$ like responses
cite:li2016deep. However this is out of the scope of this thesis.

\toReview
S_i uses memories, which are just responses from previous conversations to the
current meaning.
S_e uses sense information, just some meanings that are in the environment.

\toReview
We listed the function attitudes $f_a$ and their required information into
table [[tab:fa-and-data]]. To finish modeling the believes we just need to
the meaning graph. The meaning graph $G$ is a set of connections $(m_1, m_2)$
where $m_1, m_2 \in \mathcal{M} \wedge m_1 \neq m_2$.
Therefore $B = (m, h, h', [m], [D], G)$

#+CAPTION: function attitudes and their required data
#+NAME:   tab:fa-and-data
| Function | required data         |
| $T_e$    | A goal $m$            |
| $T_i$    | A goal $m$            |
| $F_e$    | Group values $h$      |
| $F_i$    | Personal values  $h'$ |
| $S_e$    | Sense information $[m]$ |
| $S_i$    | Memories $[D]$        |
| $N_e$    | Meaning graph         |
| $N_i$    | Meaning graph         |

\todo[inline]{Intuition does backward chaining twards what I want, with milestones to get twoards a goal, can go wrong by getting into a loop}
\todo[inline]{Sensing does forward chaining, waht do I have and ho do I get there. It is very parnoid of not being able to get the next step, can go wrong trough oversight loss}
\newpage

** Consistency with theory
\toReview
In this section we will explore if especially INTJ and ENTJ (MBTI) types would
produce different actions by analyzing when the functions would act.
We will only look at the first two functions because it is enough:
The first two functions of INTJ are:
\[N_i > T_e \]
And of ENTJ they are:
\[ T_e > N_i \]

\toReview
What we would expect is that the $T_e$ and $N_i$ produce different results
because of the order they are in the sequence.
So in case of ENTJ if $T_e$ receives an meaning $M_t$ from the user
it will pass it directly to the next function since it can't make decisions
based on a single meaning. Then once the $N_i$ function returns a reply
(which has the entire meaning tree in it) it can judgments based on these 
meanings producing a final reply.
In case of INTJ the $N_i$ function would generate the meanings based on its
data structure and pass this tree with the children to $T_e$ to assign values
to it.
Then it can either return this result or pass it to the /next/ function and
judge these results again.

\toReview
In any case the main difference is that an INTJ $T_e$ function gets to
value before the other functions get a chance to do anything. In case of an
ENTJ it is always just a final judgement.

\toReview
INTJ and INTP are different in attitudes, but have the same order.
Since attitudes produce a different process by definition
(see section [[Mapping to process]]),
we can conclude that they will also behave differently.

* Implementation
\todo[inline]{How to go from process orientated to selecting an answer?}
\drafting
The communicate game was created to make students able to practice
communicating cite:jeuring2015demo.
To put this in game form is ideal because it allows doctors to practice the
basics without the need for another human patient.
However, the current implementation does not have personality implemented.
This means every virtual patient will always react the same way,
which makes it difficult to practice the same situation several times,
since you can just start memorizing responses that work.
It turns out however the issues most doctors struggle with isn't so much
being sensitive, but rather being sensitive to the people who appreciate it.
cite:clack2004personality

\drafting
Whenever one starts working on an existing software project the first obstacle
faced is building/executing the project, this is discussed in detail in the
appendix [[building]].

\todo[inline]{Proposed Extension, why this extension}

** From strings to meanings
<<From strings to meanings>>
\todo[inline]{Can we use ontologies for the meaning part?}
\toReview
The first step is to map the user input which is of type String at time $t$
into type $M_t$ for meaning at time $t$.
For this the AIML is used. It can matched, however the langauge has to be
modified to not just produce a reaction but instead indicate what the meaning
is of a reaction.
We will use an example to illustrate the differences:

#+BEGIN_SRC xml
<aiml>
	<category>
		<pattern>
			How are you
		</pattern>
		<template>
			Not doing too well today.
		</template>
	</category>
	<category>
		<pattern>
			How * you
		</pattern>
		<template>
			<srai>How are you</srai>
		</template>
	</category>
</aiml>
#+END_SRC
So the modification would now look like:

#+BEGIN_SRC xml
  <aiml>
	  <category>
		  <pattern>
			  How are you
		  </pattern>
		  <meaning>
            StatusInquery
		  </meaning>
	  </category>
	  <category>
		  <pattern>
			  How * you
		  </pattern>
		  <meaning>
            StatusInquery
		  </meaning>
	  </category>
  </aiml>
#+END_SRC

\toReview
These changes loose reactive nature of the chatbot,
rather than saying how to reply directly to certain kind of responses we just
say what they mean in this social context.

*** Meaning to string
\toReview
But now what if the agent wants to do a status inquery, well the string
into a status inquery is already available, we just need to separate the literal
strings from the catch all patterns:

#+BEGIN_SRC xml
  <aiml>
	  <category>
		  <literal>
			  How are you?
		  </literal>
		  <patterns>
			  <pattern>How * you</pattern>
			  <pattern>How are you *</pattern>
		  </patterns>
		  <meaning>
            StatusInquery
		  </meaning>
	  </category>
  </aiml>
#+END_SRC

\toReview
If the agent wants to do a status inquery it will use the literal,
if a user string needs to be converted to a meaning we first look at all
available literals and then we start with the patterns.
So if the agent wants to reply to this it will use its personality
functions to put in the meaning out of which comes a reply, which contains
a meaning and therefore also a literal with the text it needs to say.

\toReview
Finally we can remove both the aiml tags and category tags and use the value
of the meaning tags as the file name to ensure there is always one meaning.
Thereby we leave the aiml tags and category tags implicit and the meaning
name derived since you need to have a filename anyway.
This results in a much more terse definition:

#+BEGIN_SRC xml
<literal>
    How are you?
</literal>
<patterns>
    <pattern>How * you</pattern>
    <pattern>How are you *</pattern>
</patterns>
#+END_SRC

*** using yml
Now since the above isn't technically valid xml (you can't have multiple root
nodes) we can use a more terse langauge
such as yml:

#+BEGIN_SRC yml
literal: How are you
patterns:
  - How * you
  - How are you *
#+END_SRC

Finally we can extend the pattern functionally by simply using regex support.
This will make the patterns more precise:

#+BEGIN_SRC yml
literal: How are you
patterns:
  - ^How (*.) you$
  - ^How are you (*.)
#+END_SRC

This is more verbose but also more precise.

\todo[inline]{If we have time we can compare information per character between the new and old method, going from 251 to 131 is quite an improvement}
# https://developer.jboss.org/wiki/FunctionalProgrammingInDrools

** Representing actionable meanings
\drafting
For our bot to do deliberation we need to be able to tell it which meanings
can logically follow which other meanings. To do this we use a meaning graph.
However there are multiple ways to represent this.
First of all we have intrusive graph representation, where the edges a node goes
to is put inside the node. Non intrusive representation is where edges are
stored as node tupples in a separate list, note that these are usually directed,
since you can make an edge undirected by just adding another tupple with the
values swapped, but if they're all undirected you cannot represent directed
connections without introducing more terms.

\drafting
There are arguments for both representation, an intrusive graph
representation is more easy to understand for humans, however a non intrusive
representation is more elegant and can handle things such as backward chainging
more easily (since not all nodes have to be searched in this case).

\drafting
Since we need to do both backward Chaining /and/ make it easy understandable for
humans, we will reprsent the graph as intrusive in the AIML reprsentation, but
as non intrusive in memomory for easy backward and forward chaining.

\todo{AIML with graph stuff}

** Reprsenting scoring and emotions
\drafting
Once we threw out AIML we also threw out the work on scoring and emotions.
This is of course not acceptable so we need to re-add this.
It can be easily done by adding extra meta data to the edges in the graph
representation.

\drafting
For example if we go from:

\[ M(Greeting) \to M(StatusInquery) : F(Pleased) \]

\drafting
If this path is walked by the user the bot will be pleased, however if the bot
is impatient and can look at this connection and see what this path results in.
The context is not treated in the data, this is left to the drools to figure
out.
We can elaborate this further by adding protocols that are expected into the
edges:

\[ M(StatusInquery) \to M(HealthProblemAsked) : F(Neutral), P(HealthAsked) \]

\drafting
If the user deviates from the meaning graph we can just use a default F
response of being surprised or confused.
On the other hand if the user ever tries to re-treat a subject we can just
become annoyed. Drools can be used to catch these kind of cases effectively.

** Inserting meaning into KIE
\drafting
Once the meaning is extracted from the user utterance we can insert it into the
drool engine to do deliberation upon (see [[fig:insert_meaning]]).

#+NAME: fig:insert_meaning
#+BEGIN_SRC plantuml :file img/uml/insert_meaning.png :exports results
|WebSocket|
start
:Receve message;
|#CCDDDD|AIML bot|
:Pattern match meaning from message;
:Insert meaning into KIE;
|#AntiqueWhite|Drool|
:Fire meaning deliberation rule;
:Insert Response Dialogue tree;
:Fire send response rule;
|#CCDDDD|AIML bot|
stop
#+END_SRC
#+CAPTION: Activity diagram of a server game insert_meaning
#+LABEL: fig:insert_meaning
#+RESULTS: fig:insert_meaning

\newpage
* In conclusion
\todo[inline]{Discussion, comparison}
** Future work
\todo[inline]{Depending on the successfulness this chapter becomes smaller and more fine grained}
* Appendix
** A. References
:PROPERTIES:
:UNNUMBERED: t
:END:
<<bibliography link>>

bibliographystyle:unsrt
bibliography:refs.bib


\newpage
** B. Building
:PROPERTIES:
:UNNUMBERED: t
:END:
<<building>>
\cleared
To build this project two hurdles need to be overcome, because the
server uses a starkly different tool chain than the client.
In this appendix we will record how the application can be build.
It may seem trivial but the Java EE world is incredibly complex.
We assume a unix-like operating system with a package manager.

*** Client
\cleared
The client is relatively easy too setup since its build with a
monolithic environment.
Therefore you need to have the unity editor.
The only issues with the client were an incomplete merge and a dangling
import that produced build errors.
Also note that there exists a Linux editor,
its just not officially supported (yet) but the latest version can be found [[https://forum.unity3d.com/threads/unity-on-linux-release-notes-and-known-issues.350256/][here.]]

*** Server
\cleared
The server runs on Java, therefore the first step is to install Java.
In our case java 8 was used. If your system uses portage you can use the
following command:

#+BEGIN_SRC sh
   # emerge dev-java/oracle-jdk-bin
#+END_SRC

**** Maven
\cleared
Then maven needs to be installed since gradle didn't work ([[Gradle attempt]]):

#+BEGIN_SRC sh
   # emerge dev-java/maven-bin
#+END_SRC

\cleared
Maven is the package manager for java software, it downloads and installs
dependencies (and dependency dependencies) automatically based on xml
configuration.
Do note that to use maven you need to setup a \url{\string~/.m2/settings.xml}
file. I based mine on [[https://maven.apache.org/settings.html][this]] with help of [[https://maven.apache.org/ref/3.3.9/maven-settings/settings.html][this.]]
The active profile should have the name local so that the local profile is used
in the maven project (in this case /local/).
Otherwise the wildfly plugin won't deploy the application.
To test if maven works go to the \url{communicate2/communicate/communicate_server}
folder and execute:

#+BEGIN_SRC sh
 $ mvn compile
#+END_SRC

\cleared
If no errors occur it means the settings are configure right.
However we are not done yet since the resulting binary is not executable.
It is something called a servlet which is an api for server like applications.
To use this binary, we need an application server.
Our maven repository and code base has been configured towards /wildfly/,
so we will use that.

***** Gradle attempt
<<Gradle attempt>>
\cleared
it was attempted to replace maven with gradle, since its a lot less verbose
than maven and easier to setup however doesn't have the picketlink extension
which wildfly requires.
Therefore gradle was abandoned and the maven tool was used instead.

**** Get wildfly
\cleared
Download wildfly from [[http://wildfly.org/downloads/][here]], choose the full web distribution
(if you choose the servlet one you'll run into trouble since it doesn't have the
datasource subsystem, it took about two days to figure that out).
Extract this download somewhere which we will call hence forth $WILDFLY.

**** Setup datasource
\cleared
Now its time to configure the persistent datasource.
The code base can handle sessions,
but to deal with user registration and logins and such we need a database.
There are two methods, mariadb and the in ram storage.
Mariadb is what the online application uses and its probably better to
stick to that for active devlopment, but if you just want to have
a quick look at the server you should use look at section [[inmemorydb]].

**** Mariab setup
\cleared
So first install mariadb (or mysql, they are the same, except mariadb has better
defaults):
#+BEGIN_SRC sh
  # emerge dev-db/mariadb
#+END_SRC
\cleared
Then we need to setup the user and database:
#+BEGIN_SRC sh
    $ mysql -u root
    > create database salve;
    > GRANT ALL PRIVILEGES ON salve.* To 'salve'@'localhost'
    IDENTIFIED BY 'salve';
#+END_SRC

**** Mariadb driver
\cleared
Now we need to make the application server aware of the database.
To do this we first need to install a driver from here [[http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.33/mysql-connector-java-5.1.33.jar][here]],
then copy this jar into
\url{$WILDFLY/modules/system/layers/base/com/mysql/driver/main}
you probably need to make everything after base.
Also create another file called \url{module.xml} with the following content:
#+BEGIN_SRC xml
<module xmlns="urn:jboss:module:1.3" name="com.mysql.driver">
 <resources>
  <resource-root path="mysql-connector-java-5.1.33.jar" />
 </resources>
 <dependencies>
  <module name="javax.api"/>
  <module name="javax.transaction.api"/>
 </dependencies>
</module>
#+END_SRC

**** Wildfly datasource
\cleared
Now the /driver/ is installed we need to configure it as a datasource.
To do this we move to \url{$WILDFLY/bin}.
Then execute the following commands:
#+BEGIN_SRC sh
   $ chmod +x add-user.sh jboss-cli.sh standalone.sh
   $ ./standalone.sh &
   $ ./jboss-cli.sh --connect controller=localhost
   --command="/subsystem=datasources/jdbc-driver=mysql:add(driver-name="\
   "mysql,driver-module-name=com.mysql.driver,driver-class-name="\
   "com.mysql.jdbc.Driver)"
   $ ./add-user.sh
   $ xdg-open localhost:9990
#+END_SRC

\cleared
That last command should open the browser. Click then
Configuration \to subsystems \to datasrouces \to non xa \to add  \to mysql \to next.
The name should be GameDS and the JNDI name should be java:/GameDS,
now click: next \to detect driver \to mysql.
The url should be \url{jdbc:mysql://localhost:3306/salve}, the username and pass
should both be salve, now click next \to finish.

**** Deploying
\cleared
first go to the \url{communicate2/communicate/communicate_server} folder.
Then to deploy the application the following command is used:

#+BEGIN_SRC sh
 $ mvn wildfly:deploy
#+END_SRC

\cleared
If your build gets stuck because it tries to find communicate jars from the 
internet it can help to go to the root folder and execute:

#+BEGIN_SRC sh
 $ mvn compile
#+END_SRC

**** Alternative: in memory db
\cleared
<<inmemorydb>>
Now there is a choice to be made, you can either choose to use maria db
or try and point the appliation to the in ram storage of wildfly.
To do this go to:
\url{communicate2/communicate/communicate_server/src/main/resources/META-INF}
and then replace everything with:
#+BEGIN_SRC xml
  <?xml version="1.0" encoding="UTF-8"?>
  <persistence version="2.1"
  xmlns="http://xmlns.jcp.org/xml/ns/persistence"
  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
  xsi:schemalocation=
  "http://xmlns.jcp.org/xml/ns/persistence 
http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
  >
      <persistence-unit name="salve_persistence_unit"
          transaction-type="JTA">
          <jta-data-source>java:jboss/myDs</jta-data-source>
          <properties>
              <property name="hibernate.dialect"
                        value="org.hibernate.dialect.H2Dialect" />
              <property name="hibernate.max_fetch_depth" value="3" />
              <property name="hibernate.hbm2ddl.auto" value="update" />
              <property name="hibernate.show_sql" value="true" />
          </properties>
      </persistence-unit>
  </persistence>
#+END_SRC

*** Notes
\cleared
If you're located in the communicate_server folder, The rebuild everything
command is:
#+BEGIN_SRC sh
rm -R ~/.m2/repository/cnruithof; (cd ../ && mvn clean && mvn install) && mvn wildfly:deploy
#+END_SRC
This will re-install the entire project thereby also rebuilding all dependencies.
mvn clean in there for good measure.

\cleared
There is a python client script for quick debugging, therefore its unnecessary
to keep unity running (or use at all).

** Ideas
:PROPERTIES:
:UNNUMBERED: t
:END:
\todo[inline]{To circumvent typing errors of users we can put input trough a spell checker taking the first correction}
\todo[inline]{Regex mathing as an extension to existing matching}
\todo[inline]{How to deal with long inputs? I think sentence splitting was mentioned?}
\todo[inline]{Perhaps we can use argumentation research on top of the graph to figure out more semantics (this statment is attacking that or inquerying this)}
*** Tooling stuff
+ Protocol buffers could be used for protocol. Its strongly typed and has both
  C# and Java bindings
+ xml shouldn't be used as a procudual langauge (http://wiki.c2.com/?XmlAbuse)
  its probably better to replace it with yaml https://en.wikipedia.org/wiki/XML#Criticism
  (seriously most of the code of alice bot involvelves mapping xml into objects
  (for which exist libraries https://stackoverflow.com/questions/15881876/mapping-xml-entities-to-java-objects)
  and valiating it, (which can be done by an xsd better anyway)).
*** Security
+ Don't send passwords as plain text over the network.
+ Use SSL.
+ Probably should hire an expert to do an audit.

*** Protocol
Start game and new game could be merged?
Why are you logging towards the client? This seems like a security hole and a
possible performance bottleneck.
